---
layout: post
title: "C和指针[Kenneth A.Reek 著]"
description: ""
category: 读书笔记
tags: []
---
{% include JB/setup %}

###第一章：快速上手  
1.使用scanf函数进行用户输入的时候，需要注意：  
使用所有格式码(除了%c之外)时，输入值之前的空白(空格、制表符、换行符等)会被跳过，值后面的空白表示该值的结束。  
也就是说只有%c还会响应用户的空白输入，其他都会忽略重复的空白。  


###第二章：基本概念  
1.不良的风格和不良的文档是软件生产和维护代价高昂的两个重要原因。  
良好的编程风格能够大大提高程序的可读性。良好的编程风格的直接结果就是程序更容易正确运行，间接结果就是他们更容易维护。  


###第三章：数据  
1.typedef：自定义数据类型  
	typedef char *ptr_to_char;	//自定义字符型指针的类型名为：ptr_to_char
	ptr_to_char a;				//使用自定义的数据类型声明变量a
	等价于
	char *a
应该使用typedef而不是#define来创建新的数据类型名，请看下例：  
	#define d_ptr_to_char char *
	d_ptr_to_char a, b;
	等价于
	char *a, b;

2.使用define时需要常加括号，以免优先级的变化改变代码的初衷  


###第四章：语句  
1.在使用if语句时，即使对应的代码块仅有一条语句也要保持使用括号的习惯  

2.在每一个switch语句中都使用default子句  

	
###第6章：指针  
1.理解变量名与内存地址  
名字与内存位置至今的关联并不是硬件所提供的，它是由编译器为我们实现的。所有这些变量给了我们一种更方便的方法"记住地址"  
硬件仍然通过地址访问内存位置。  

2.值的类型并非值本身所固有的一种特性，而是取决于它的使用方法。  
所以下面这段代码，能够在使用ASCII码的系统中实现字符型转为整形  
	char a;
	int b;
	a = '3';
	b = (int)a - '0';	//将a作为一个整数使用，减去'0'(整形的48)。b的值为3

3.变量的值就是分配给该变量的内存位置所存储的数值，即使是指针变量也不例外  

4.对所有的指针变量进行显示的初始化是种好做法。如果已经知道指针将被初始化为什么地址，就把它初始化为该地址，否则就把它初始化为NULL  
风格良好的程序会在解引用之前对它进行检查，这种初始化策略可以节省大量的调试时间  

5.关于指针表达式  
通过一些例子，详细解释常见的指针表达式  
	//声明
	char ch = 'a';
	char *cp = &ch;
	char tmp, *tmp_p;

	ch = 'b';	//ch作为左值使用，表示变量ch的内存地址，语句的含义是将'b'写到ch所在的内存地址
	tmp = ch;	//ch作为右值使用，表示变量ch的值，即'a'
	
	tmp_p = &ch;	//&ch仅能作为右值使用，表示变量ch的内存地址

	cp = &ch;		//cp作为左值，表示cp的内存位置，语句含义是将&ch写到cp所在的内存地址
	tmp_p = cp;		//cp作为右值，表示cp的值，即ch的内存位置

	tmp = *cp		//*cp作为右值，表示'cp指向的内存位置的内容'，即ch的值
	*cp = 'b'		//*cp作为左值，表示'cp指向的内存位置'，即ch的内存地址

	*(cp + 1) 与 *cp + 1的区别：前者作为右值表示取cp所指向内存地址(即ch的内存地址)的下一个地址中的内容，后者表示取ch中的值，然后加1
	++cp：只能作为右值使用。将cp指向的地址后移1个单位，返回移动后cp的一个拷贝
	cp++：只能作为右值使用。先返回cp的一份拷贝，然后增加cp的值

	*++cp: 先对cp后移一个单位，然后解引用
	*cp++: ++操作符产生cp的一份拷贝，然后cp后移一个单位，最后对得到的拷贝进行解引用
注：后缀++操作符优先级高于解引用*操作符。所以会误认为*cp++是等同*(cp + 1)的，但实质上确实执行上述的操作。对于这种容易混淆的表达式，应减少使用  


###第七章：函数  
1.在表达式内部调用一个无返回值得函数是一个严重的错误，因为这样一来在表达式的求值过程中会使用一个不可预测的垃圾值。所幸的是现代编译器通常能捕捉到这类错误  

2.函数声明的时候，必须指定参数的类型。但是在函数原型中加入描述性的参数名是明智的，因为它可以给希望调用该函数的人员提供更多有用的信息  

3.一个没有参数的函数的原型应该写成下面这个样子：  
	int func( void )
关键字void提示没有任何参数，而不是表示它有一个类型为void的参数  

4.C函数的所有参数均以“传值调用”方式进行传递  

5.stdarg宏的使用  
可变参数列表是通过宏实现的，这些宏定义在头文件stdarg.h，它是标准库的一部分。  
这个头文件声明了一个类型va_list和三个宏---va_start, va_arg, va_end。  
下面是书中的例子：  
	#include<stdarg.h>	//包含响应头文件
	float average( int n_value, ... )	//第一个参数是必须给出的，通常使用这个参数指定剩余的参数个数
	{
		va_list var_arg;	//它用于访问参数列表的未确定部分
		va_start( var_arg, n_value );	//使用va_start函数对va_list变量进行初始化，第二个参数是省略号前最后一个有名字的参数  
		//初始化过程把var_arg变量设置为指向可变参数部分的第一个参数
		for(count = 0; count < n_value; count++ ){
			sum += va_arg( var_arg, int );	//使用va_arg函数访问变量，接受两个参数：va_list变量和参数列表中下一个参数的类型
		}
		va_end( var_arg );
		return sum / n_value;
	}

6.抽象数据类型可以减少程序对模块实现细节的依赖，从而提高程序的可靠性  


###第八章：数组  
1.在C中，在几乎所有使用是组名的表达式中，数组名的值是一个*指针常量*，也就是数组第1个元素的地址。  
只有在两种场合下，数组名并不用指针常量来表示：  
a.当数组名作为sizeof操作符：sizeof返回这个数组的长度，而不是指向数组的指针的长度  
b.单目操作符&的操作数：取一个数组名的地址所产生的是一个指向数组的指针，而不是一个指向某个指针常量的指针  

2.指针与下标：假设这两种方法都是正确的，下标绝对不会比指针更有效率，但指针有时会比下标更有效率  
试比较下面两段代码：  
	int array[10], a;
	for ( a = 0; a < 10; a += 1 ){
		array[a] = 0;
	}

	int array[10], *ap;
	for ( ap = array; ap < array + 10; ap++ ){
		*ap = 0;
	}
第一段代码对于下标计算由于a是变量，所以求下标的时候都需要重复：取a的值，并把它与整形的长度(4)相乘。  
而第二段代码中对于ap++，每次都是加固定的值，且这个乘法（1*4）只在编译时执行一次。运行时并不执行乘法。  

3.当根据某个固定数目的增量在一个数组中移动时，使用指针变量将比使用下标产生效率更高的代码。当这个增量是1并且机器具有地址自动增量模型时，这点表现的更为突出  



###第九章：字符串、字符和字节  
1.strlen返回值类型为size_t，该类型是在头文件stddef.h中定义的，是一个无符号整数类型。  
所以下面两条语句，第一条效果符合预期，第二条语句结果则恒为真  
	if( strlen(x) >= strlen(y) ) ...
	if( strlen(x) - strlen(y) >= 0 ) ...

2.不要试图自己编写功能相同的函数来取代库函数，同时使用字符分类和转换函数可以提高函数的移植性  

