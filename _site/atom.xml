<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>My blog</title>
 <link href="http://perthcharles.github.com/" rel="self"/>
 <link href="http://perthcharles.github.com"/>
 <updated>2013-04-15T21:33:22+08:00</updated>
 <id>http://perthcharles.github.com</id>
 <author>
   <name>Perth Charles</name>
   <email>zhongbincharles@gmail.com</email>
 </author>

 
 <entry>
   <title>Trace驱动的memory模拟：综述</title>
   <link href="http://perthcharles.github.com/papars/2013/04/13/trace-driven-survey"/>
   <updated>2013-04-13T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/papars/2013/04/13/trace-driven-survey</id>
   <content type="html">&lt;h1&gt;论文来源&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;(在google scholar中搜索：trace-driven memory simulation a survey )
#wget http://www.cs.amherst.edu/~sfkaplan/courses/spring-2004/cs40/papers/UM:TDMS.pdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;博客里面写的只是粗略的理解，错误难免。想更准确的了解还是请看论文原文。&lt;/p&gt;

&lt;h1&gt;简介&lt;/h1&gt;

&lt;p&gt;处理器速度与memory速度之间的差距越来越大，成“剪刀口”型增长趋势。在memory-system设计被硬件实现之前，找到评价memory-system设计的方法显得十分重要。&lt;br/&gt;
其中一种有效的方法就是：通过抓取真实应用的访存trace，然后通过在模拟器上模拟抓取下来的trace行为达到测试memory-system的性能效果。下面将根据前面提到的论文，适当整理思路，以便之后学习。&lt;br/&gt;
所谓访存trace，就是一系列的对内存进行访问的操作序列（a sequence of memory references）&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;主要难点&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1，收集完整的trace信息很难。特别是对于多进程，操作系统，动态链接或动态编译产生的访存trace很难获取。
2，访存trace一般很大。一般都是10G～100G这个量级的。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Trace driven memory simulation主要流程&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1，trace collect：    收集某些选定负载的访存序列。
2，trace reduction:    由于trace文件一般都很大，如果模拟完成的trace将会十分耗时。通过去除不需要、冗余或是不感兴趣的数据来提高整体的效率。
3，trace processing:   将得到的trace文件当初输入给模拟器处理
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;对各类方法的评价标准&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;准确性：    模拟出来的性能与真实性能之间的差距；reduction之后的trace模拟结果与完成trace模拟结果之间的差异等
速度：       每秒收集到的trace entry个数（无法跨平台对比）；entry收集速度/entry产生速度;entry processing速度/entry产生速度；总模拟时间/正常执行时间
额外的内存开销
reduction 比例
portability,flexibility,expense,easy-of-use
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Trace collect&lt;/h3&gt;

&lt;p&gt;评价trace质量的标准主要就是：完整性和详细性。另外在收集过程中，不得收录额外引起的访存动作，主要就是收集工作本身产生的访存动作不应该被收录到trace中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;完整性：所有的访存动作都要收集，包括所有用户级进程和操作系统内核产生的访存动作。
详细性：是否给trace添加一些额外的信息，比如VM page-table状态，访存动作类型（读，写，执行），大小（字，半字，字节等）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般的工具在收集的时候如果trace buffer写满了，都需要停下来将buffer里面的数据导出到外部。&lt;br/&gt;
各种工具收集方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trace收集方式的不同主要体现在收集动作对应系统层次的不同
------------软件层次-------------
|   操作系统级的单步执行  |
|   编译器           |
|   汇编器           |
|   连接器和加载器       |
|--------------------------------
|   微指令           |
|--------------------------------
|   物理层：探测物理信号  |
---------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Trace reduction&lt;/h3&gt;

&lt;p&gt;各类方法的主要不同在于reduction比例的不同和reduction方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;主要reduction方式：
压缩：       利用标准的数据压缩算法对数据进行压缩（觉得这种方法不实用）
重要事件： 在收集trace的时候只收集满足一定条件的trace，详见论文
过滤：       由于每个研究人员的研究兴趣重点不同，想要模拟的trace类型也就不同
抽样：       分时间抽样和集合抽样。（这种方法使用组内开发的工具：HMTT实践过）
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Trace processing&lt;/h3&gt;

&lt;p&gt;因为memory-system设计的多样性（页面替换算法、cache大小、写策略：写穿透等，line大小），所以在将trace输入到模拟器时，自然就想一遍输入，就能跑几种不同的配置方式。为了达到这个目的就导致来trace processing方式的多样性。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;转载请注明出处。&lt;br/&gt;
版权所有，侵犯必究&lt;/p&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>linux 命令学习（五）</title>
   <link href="http://perthcharles.github.com/2013/04/12/linux-using"/>
   <updated>2013-04-12T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/04/12/linux-using</id>
   <content type="html">&lt;h2&gt;/etc/motd使用&lt;/h2&gt;

&lt;p&gt;如果你正在使用一台服务器，并且想通知每一个新登录这台服务器的用户一个消息。&lt;br/&gt;
比如你需要在服务器上进行一些测试工作，肯定希望其他登录进来的用户不要跑别的程序。这时你可以在/etc/motd文件中编辑你的通知消息，每一个新登录的用户都会看到这个消息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cat /etc/motd
Hello everyone,
This server will be used to run some test-programs at 2013/04/12 0:00 ~ 24:00
Please do not login server at this time. ^_^
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;找出含特定字符串的所有文件&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#grep -ir (string-to-find) (search-files)
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>X window</title>
   <link href="http://perthcharles.github.com/2013/03/28/x-window"/>
   <updated>2013-03-28T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/28/x-window</id>
   <content type="html">&lt;h2&gt;Type of XEvent&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Keyboard events                | KeyPress, KeyRelease
Pointer events                 | ButtonPress, ButtonRelease, MotionNotify
Window crossing events         | EnterNotify, LeaveNotify
Input focus events             | FocusIn, FocusOut
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考资料：(X Window学习xlib---X Event)[http://blog.csdn.net/unailbobo/article/details/3036618]&lt;/p&gt;

&lt;h3&gt;问题&lt;/h3&gt;

&lt;p&gt;如果仅仅是调整x window的位置，是不是没有数据发送出去？！  ----添加DEBUG，只是调整位置，看是否有数据包发送&lt;/p&gt;

&lt;p&gt;怎么给X window发送event?？？？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;关键点：xwin_process_events函数调用XNextEvent来从g_display中获取event事件，所以问题变为如何在g_display中加入我们想要的事件？？？
    这种方式现在还没思路，改用直接调用rdp_send_input()函数来处理
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在需要保证前后发送的两个数据包依赖性要保证好，比如第一个操作是打开word，那么第二个操作必须等服务器那边发送回响应后才发送过去&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;关键问题：怎么设置响应时间？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果单纯的从rdp_send_input发送数据（比如移动鼠标），那么返回数据后，客户端是否能显示正常？这点要验证！&lt;/p&gt;

&lt;p&gt;Standard KeySym names are obtained from &amp;lt;X11/keysymdef.h&gt; by removing the XK_ prefix from each name.&lt;/p&gt;

&lt;h5&gt;coding log&lt;/h5&gt;

&lt;p&gt;bool RECORD is define in rdesktop.c  line:460&lt;/p&gt;

&lt;p&gt;因为想读取的是二进制文件，所以要规定一个文件格式&lt;/p&gt;

&lt;p&gt;xwin.c:2283: warning: format ‘%u’ expects type ‘unsigned int’, but argument 2 has type ‘time_t’
xwin.c: In function ‘xwin_process_events’:
xwin.c:2379: warning: format ‘%x’ expects type ‘unsigned int’, but argument 2 has type ‘KeySym’
xwin.c:2382: warning: format ‘%x’ expects type ‘unsigned int’, but argument 2 has type ‘KeySym’&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%x,  (unsigned int) keysym
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;xwin.c:2432: warning: format ‘%u’ expects type ‘unsigned int’, but argument 2 has type ‘time_t’&lt;/p&gt;

&lt;h3&gt;注意事项&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;自己定义的：FILE * record 需要用完后关闭
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;问题&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;直接设置timeout判断上一个动作是否完成不行，因为在上一个动作还在进行的时候，也有可能中途图像不变，这样虽然会timeout，但是上一个动作其实并没有完成！
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>linux 反汇编初步</title>
   <link href="http://perthcharles.github.com/2013/03/25/linux-disassemble"/>
   <updated>2013-03-25T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/25/linux-disassemble</id>
   <content type="html">&lt;h2&gt;工具&lt;/h2&gt;

&lt;p&gt;十六进制编辑器：hexedit&lt;br/&gt;
objdump:&lt;/p&gt;

&lt;hr /&gt;

&lt;h3&gt;hexedit使用&lt;/h3&gt;

&lt;p&gt;暂时只用hexedit来读二进制文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#hexedit filename  //查看文件  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作键&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   Ctrl-X: save and exit  
   Ctrl-C: exit without saving  
   tab: 在hex和ascii窗口之间切换  
   Ctrl-U: undo all  
   Ctrl-S: search forward  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;objdump使用&lt;/h3&gt;

&lt;p&gt;编译程序的时候，gcc添加-g选项，增加调试信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#gcc test.c -g -o test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-S(source):表示读取哪个文件
-j:选择读出哪个section，可以通过objdump -h来查看所有的section
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h3&gt;看懂AT&amp;amp;T汇编&lt;/h3&gt;

&lt;p&gt;由于objdump反汇编得到的结果主要都是AT&amp;amp;T格式的汇编(不过好像可以选择？)，而且linux内核代码也有不少AT&amp;amp;T格式的汇编代码，所以有必要学习一下&lt;/p&gt;

&lt;h4&gt;AT&amp;amp;T汇编特点&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;1.寄存器前面要加%，如：mov %eab,%ebx
    注意源寄存器和目标寄存器的顺序与intel汇编更好相反，at&amp;amp;t中左边是源寄存器，右边是目标寄存器。所以上面指令是将eax的值赋给ebx
2.立即数/常数前面要加‘$’,符号常数值直接用。
    关于符号常量注意理解下面两句：
    mov A,%eax  //将A代表的值赋给eax,如A=10，则eax里面的值就是10
    mov $A,%eax     //将A代表的值当作地址，将对应地址的值赋给eax，如A=0x10,0x10处存则20，则把地址0x10处对应的值20赋给eax
3.movb:8位(byte)   movw：16位(word)  movl：32位(long)  
others: s=short(16-bit integer) or single(32-bit floating point)
    q=quad(64 bits)
    t=ten bytes(80 bits floating point)
注：如果suffix没有指定且不是内存操作，GAS(Gnu AS)会根据目标寄存器的大小来决定
4.call/jmp语句的操作数前面要加上“*”作为前缀，远跳转ljmp,远调用lcall，远返回lret

5.寻址规则：displacement(base register, offset register, scalar multiplier)
  计算方法：(base+dis)+(offset*multiplier)
  举例：
    movl    -4(%ebp, %edx, 4), %eax  # Full example: load *(ebp - 4 + (edx * 4)) into eax
    movl    (%ecx), %edx             # No offset: copy the target of a pointer into a register
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;C语言内嵌汇编&lt;/h4&gt;

&lt;p&gt;格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_asm_(&quot;asm statement&quot;:outputs:inputs:registers-modified)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tips:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.在嵌入汇编中，寄存器前面要加两个%，因为gcc在编译时，会去掉一个%再输出成汇编格式
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;主要寄存器及其作用&lt;/h4&gt;

&lt;h5&gt;8086有14个16位寄存器，按照用途分为：&lt;/h5&gt;

&lt;p&gt;1.通用寄存器(8个)&lt;br/&gt;
2.指令指针(IP,1个)&lt;br/&gt;
3.标志寄存器(FR，1个)&lt;br/&gt;
4.段寄存器(4个)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;通用寄存器&lt;/em&gt;又可以分成2类：数据寄存器和指针寄存器及变址寄存器，各4个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ax:常用于计算。另外所有的I/O指令都使用这一寄存器与外界设备传送数据
bx:基址寄存器  
cx:计数寄存器  
dx:数据寄存器  

SP:堆栈指针，与SS配合使用，可指向目前的堆栈位置  
BP:基址寄存器，可作为SS的相对基址位置  
SI:source index,源变址寄存器------暂不理解  
DI：destination index,目的变址寄存器  
上面四个寄存器只能按16位进行操作，主要用来形成操作数的地址  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;指令指针IP&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IP:16位专用寄存器，用来指向当前执行指令的下一条指令的地址。注意，IP指向的是指令地址的段内地址偏移量  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;标志寄存器FR&lt;/em&gt;&lt;br/&gt;
16位的寄存器，有意义的有9位，6位是状态位，3位是控制位&lt;br/&gt;
分布图：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#################################################
#  #  #  #  #OF#DF#IF#TF#SF#ZF#  #AF#  #PF#  #CF#
#################################################
#15#14#13#12#11#10# 9# 8# 7# 6# 5# 4# 3# 2# 1# 0#
#################################################
各个标志的含义：  
OF:overflow  
DF:direction
IF:中断允许标志，标志是否响应CPU‘外部可屏蔽‘中断，1表示响应
TF:跟踪标志
SF:符号标志，与运算结果的最高位相同
ZF:零标志，反映运算结果是否为0
AF:辅助进位标志
PF:奇偶标志反映运算结果中’1‘的个数，PF=1表示偶数个’1‘
CF:进位标志反映运算结果是否产生进位或借位
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;段寄存器&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CS:code segment
DS:data segment
SS:stack segment
ES:extra segment
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4&gt;80386寄存器&lt;/h4&gt;

&lt;p&gt;寄存器都是32位宽&lt;br/&gt;
&lt;em&gt;通用寄存器&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EAX，EBX，ECX，EDX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;特殊寄存器&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ESI：通常在内存操作中作为“源地址指针”使用，DS是默认段寄存器
EDI：通常在内存操作中作为“目标地址指针”，DS是默认段寄存器
EBP：通常被高级语言编译器用以建造‘堆栈帧’来保存函数或过程的局部变量，SS是默认段寄存器
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3&gt;主要参考资料&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cppblog.com/tdweng/articles/120852.html&quot;&gt;汇编中各寄存器的作用-堂吉歌德&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax&quot;&gt;X86 Assembly/GAS Syntax&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>Gnu AS 汇编实践</title>
   <link href="http://perthcharles.github.com/2013/03/25/gnu-as-pratice"/>
   <updated>2013-03-25T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/25/gnu-as-pratice</id>
   <content type="html">&lt;h3&gt;首先尝试一个最近简单的Hello world程序&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(void) 
{
        printf(&quot;Hello, world!\n&quot;);
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存文件：hello.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#gcc hello.c -o hello
#./hello
Hello World!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;产生等价的32位X86 汇编语言程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#gcc -S -m64 hello.c  //将m32改位m64，因为我的机器是64的
#ls hello*
hello  hello.c  hello.s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到产生来与hello.c等价的汇编语言程序hello.s,下面用gcc编译这个汇编程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#gcc -m64 hello.s -o hello-asm
#./hello-asm
Hello World!
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>ssh免密码登录</title>
   <link href="http://perthcharles.github.com/2013/03/24/ssh-free-pwd"/>
   <updated>2013-03-24T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/24/ssh-free-pwd</id>
   <content type="html">&lt;h3&gt;博客背景&lt;/h3&gt;

&lt;p&gt;有时候在两台服务器上面工作，需要同时操作它们，如果在两个窗口里面反复切换就显得很麻烦。所以先配置ssh免密码登录，然后用其他工具&lt;/p&gt;

&lt;p&gt;假设A是本地主机，B是远程主机。想要从A远程访问B的时候免密码登录&lt;br/&gt;
首先在A上生成公钥和私钥，然后在B机器上记录在公钥&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#(A)ssh-keygen -t rsa //连续三次回车，这里选择不设置密码  
#(A)ssh root@ip-of-B  //这次还需要密码  
#(B)ls -a  //查看是否存在.ssh文件夹  
#(B)mkdir .ssh &amp;amp;&amp;amp; chmod 0700.ssh &amp;amp;&amp;amp; exit   
#(A)scp ~/.ssh/id_rsa.pub root@ip-of-B:.ssh/id_rsa.pub //还需要输入密码  
#(B)touch /root/.ssh/authorized_keys  //生成一个空文件，如果文件已经存在，则跳过这条命令  
#chmod 600 ~/.ssh/authorized_keys  //设置该文件只有root能查看，因为这个文件是用于保存ssh客户端生成的公钥的，该文件是在ssh服务端配置文件/etc/sshd_config中指定的  
#cat /root/.ssh/id_rsa.pub &amp;gt;&amp;gt; /root/.ssh/authorized_keys  //将A传过来的公钥写入authorized_keys文件，注意这里必须使用 &quot;&amp;gt;&amp;gt;&quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此配置完成了，现在在A上面使用ssh登录B应该就不用输入密码了。&lt;/p&gt;

&lt;h3&gt;其他说明&lt;/h3&gt;

&lt;p&gt;如果在A上面需要在脚本里面执行B机器上面的命令，除来使用实验室提供的工具外，可以简单的使用下面的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ssh root@ip-of-B:/pwd &quot;command1;command list&quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然这里只是一个简单的例子，所以生成的密钥没有设置密码。如果是短期使用可以先这样配置使用，然后再将密码从B机器上面的authorized_keys里面删除，下次你再需要用的时候再将其加进去。这样安全性要好些，如果长期使用还是建议不要使用没有密码的密钥，特别是共用服务器。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>一道C语言二进制反码题</title>
   <link href="http://perthcharles.github.com/%E9%9D%A2%E8%AF%95%E9%A2%98/2013/03/24/negation-in-c"/>
   <updated>2013-03-24T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/%E9%9D%A2%E8%AF%95%E9%A2%98/2013/03/24/negation-in-c</id>
   <content type="html">&lt;h3&gt;题目&lt;/h3&gt;

&lt;p&gt;请写出下面程序在32/64位机器上的输出结果&lt;br/&gt;
编译器：GCC&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;sdtio.h&amp;gt;  

int main(void)
{
    unsigned char a = 0xa5;
    printf(&quot;%d\n&quot;,~a);
    char b = ~a;
    printf(&quot;%d\n&quot;,b);
    unsigned char c = ~a;
    printf(&quot;%d\n&quot;,c);

    return 0;
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;解答:&lt;/h3&gt;

&lt;p&gt;char型数据占一个字节，故&lt;br/&gt;
(a)0xa5 = 1010 0101 = 165&lt;br/&gt;
但是~a并不是a直观的取反，在32位或int长度为4的64位系统中，char和unsigned char 都是按照32位（4字节）取反的，所以这样一来&lt;br/&gt;
(~a) = ~(0x000000a5) = 0xffffff5a//这点可以按照%x格式打印~a验证&lt;br/&gt;
按照%d输出的话，最高位会当成符号位&lt;br/&gt;
所以0xffffff5a先取反得到(符号位除外)&lt;br/&gt;
0x000000a5,然后+1得到//补码与原码的相互转化规则：除符号位外取反再+1&lt;br/&gt;
0x000000a6 = 166&lt;br/&gt;
符号为负，所以第一条打印信息为-166&lt;/p&gt;

&lt;p&gt;解释完第一条打印信息，后两个就好解释了，因为先将~a存入到了char或unsigned char型中，~a取反后的高位被抛弃，所以直接得到0x5a，即90&lt;/p&gt;

&lt;h3&gt;更进一步&lt;/h3&gt;

&lt;p&gt;将下面代码反汇编，查看取反操作是否是上面的说法：按照32位取反&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
int main(void)
{
    unsigned char a = 0xa5;
    printf(&quot;%d\n&quot;,~a);

    return 0;
}

#gcc test.c -o -g test 
#objdump -S test &amp;gt; test.debug
#cat test.debug
...
00000000004004c4 &amp;lt;main&amp;gt;:
#include&amp;lt;stdio.h&amp;gt;
int main(void)
{
  4004c4:   55                      push   %rbp
  4004c5:   48 89 e5                mov    %rsp,%rbp
  4004c8:   48 83 ec 10             sub    $0x10,%rsp
    unsigned char a = 0xa5;
  4004cc:   c6 45 ff a5             movb   $0xa5,-0x1(%rbp)
    printf(&quot;%d\n&quot;,~a);
  4004d0:   0f b6 45 ff             movzbl -0x1(%rbp),%eax
  4004d4:   89 c2                   mov    %eax,%edx
  4004d6:   f7 d2                   not    %edx
  4004d8:   b8 f8 05 40 00          mov    $0x4005f8,%eax
  4004dd:   89 d6                   mov    %edx,%esi
  4004df:   48 89 c7                mov    %rax,%rdi
  4004e2:   b8 00 00 00 00          mov    $0x0,%eax
  4004e7:   e8 cc fe ff ff          callq  4003b8 &amp;lt;printf@plt&amp;gt;

    return 0;
  4004ec:   b8 00 00 00 00          mov    $0x0,%eax
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到指令&quot;not %edx&quot;是直接按照32位进行取反的&lt;br/&gt;
如果对程序进行-O2优化编译的话，就看得更直观&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#gcc -O2 test.c -g -o test-O2
#objdump -S test-O2 &amp;gt;test-O2.debug
#cat test-O2.debug
...
00000000004004d0 &amp;lt;main&amp;gt;:
#include&amp;lt;stdio.h&amp;gt;
int main(void)
{
  4004d0:       48 83 ec 08             sub    $0x8,%rsp
     unsigned char a = 0xa5;
     printf(&quot;%d\n&quot;,~a);
  4004d4:       be 5a ff ff ff          mov    $0xffffff5a,%esi
  4004d9:       bf e8 05 40 00          mov    $0x4005e8,%edi
  4004de:       31 c0                   xor    %eax,%eax
  4004e0:       e8 d3 fe ff ff          callq  4003b8 &amp;lt;printf@plt&amp;gt;

     return 0;
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到程序直接将0xffffff5a赋给esi寄存器了&lt;/p&gt;

&lt;h3&gt;我本子相关信息&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#uname -r
2.6.32-358.el6.x86_64
#gcc -v
gcc version 4.4.7 20120313 (Red Hat 4.4.7-3) (GCC)
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>硬盘安装linux</title>
   <link href="http://perthcharles.github.com/2013/03/24/install-linux-from-disk"/>
   <updated>2013-03-24T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/24/install-linux-from-disk</id>
   <content type="html">&lt;h3&gt;介绍&lt;/h3&gt;

&lt;p&gt;目前正在用的系统是WIN7系统，由于现在系统性能表现越来越差，而自己又不想重新安装这个系统，所以就选择在电脑上面安装双系统。&lt;br/&gt;
再者最近在学习linux，所以就干脆选择安一个linux来玩玩，目前选择的是CentOS6.4。至于为什么选择这个版本，大家都知道的：稳定！当然这样一来桌面软件支持就略显不足，不过暂时够用就好。&lt;/p&gt;

&lt;h3&gt;用到的软件&lt;/h3&gt;

&lt;p&gt;EasyBCD:这款软件用来帮助你在WIN7系统下面制作启动项。这里只简单说明我用的步骤，更具体的使用方法请&lt;a href=&quot;www.google.com&quot;&gt;google之&lt;/a&gt;&lt;br/&gt;
wingrub:利用这个软件，可以帮助你在制作EasyBCD启动项的时候确定你需要选用的分区号。&lt;br/&gt;
Acronis Disk Director Suite:帮助你在WIN7下无损分区，目前用户体验良好。不过保险起见，最好还是先备份重要文件啦。&lt;/p&gt;

&lt;h3&gt;安装步骤&lt;/h3&gt;

&lt;p&gt;话不多说，这就开工&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;打开EasyBCD-&amp;gt;  
Add New Entry-&amp;gt;  //这一步就是给你liunx镜像文件制作启动项，或许在linux下更准确的说法是修改grub？  
选择NeoGrub标签页-&amp;gt;  
点击Install,点击Configure,进行配置，其实我感觉这个是标准的grub的写法。最重要的是各个操作系统的配置文件对应镜像需要解压出来的文件有区别，这点很重要。很多人的博客并没有明显的区分或是主要针对Ubuntu这个系统进行讲解的    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最重要的就是配置了，这个地方网上有不少人进行了解释，但是我觉得我觉得最简单最实用的还是百度空间的&lt;a href=&quot;http://hi.baidu.com/sf_chipan&quot;&gt;小治的空间&lt;/a&gt;,在此感谢作者！&lt;/p&gt;

&lt;h3&gt;各个系统的配置文件写法和镜像需要解压缩的文件&lt;/h3&gt;

&lt;h4&gt;CentOS系列&lt;/h4&gt;

&lt;p&gt;文件目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CentOS-xx-i386/x86_64-bin-DVD1/2.iso  
initrd.img  //initrd.img和vmlinuz这两个文件在ioslinux文件夹下  
vmlinuz  
images/  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;title install centos XXX  
kernel (hd0,6)/vmlinuz  //hd0 表示你的镜像文件放在你电脑对应的那块硬盘；6表示镜像存放分区的编号。  
initrd (hd0,6)/initrd.img  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;其他系列&lt;/h4&gt;

&lt;p&gt;其他发行版本目前还没有尝试，有需求的话，可以去参考百度空间的&lt;a href=&quot;http://hi.baidu.com/sf_chipan&quot;&gt;小治的空间&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;几点注意事项&lt;/h4&gt;

&lt;hr /&gt;

&lt;p&gt;配置文件中对应的分区编号可以用wingrub帮忙确定的^_^&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;镜像文件最好放在linux能够识别的文件系统中，由于FAT32单个文件最大不能超过4G，对于CentOS-DVD安装可能就不能可行了。大家可以尝试放到ext系列的文件系统下(推荐ext3)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;再多说一句，如果你想在WIN7环境下识别ext3文件系统的分区的话，可以安装Ext2Fsd这个软件。&lt;/p&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>在centos系统下，挂在ntfs格式的磁盘分区</title>
   <link href="http://perthcharles.github.com/centos6.4/2013/03/24/centos-mount-ntfs"/>
   <updated>2013-03-24T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/centos6.4/2013/03/24/centos-mount-ntfs</id>
   <content type="html">&lt;h3&gt;前提介绍&lt;/h3&gt;

&lt;p&gt;在我在WIN7系统下硬盘安装好双系统后，有不少时候需要访问一些WIN7系统下的文件，如果反复的重启电脑的话那就太烦人了。而Centos又不能直接挂载ntfs格式的磁盘分区，网上搜来一圈找到一个可行的方法&lt;/p&gt;

&lt;h3&gt;需要的软件&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;fuse&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#rpm -qa |grep fuse //查看系统是否已经安装软件  
#yum list |grep fuse  
#yum install fuse  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你的源里面没有这个软件，那就去添加更好的源吧，不会添加源的可以参照我另一片博客：&lt;a href=&quot;http://perthcharles.github.com/centos6.4/2013/03/18/yum-using&quot;&gt;yum使用指南&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ntfs-3g&lt;/em&gt;&lt;br/&gt;
这个软件我选择的从源码安装，当然你也可以选择从yum源安装&lt;br/&gt;
&lt;a href=&quot;http://www.tuxera.com/community/ntfs-3g-download/&quot;&gt;ntfs-3g下载地址:www.tuxera.com/community/ntfs-3g-download/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;挂在分区&lt;/h3&gt;

&lt;p&gt;在安装好上面这两个软件后，应该就可以挂在ntfs磁盘分区了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#fdisk -l //查看硬盘所有分区  
#mount -t ntfs-3g /dev/xxx /mnt/xxx  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想开机就挂在上的话，我的方法是修改/etc/profile，再最后加上上面的mount命令&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>vim 编码相关问题</title>
   <link href="http://perthcharles.github.com/2013/03/23/vim-decode"/>
   <updated>2013-03-23T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/23/vim-decode</id>
   <content type="html">&lt;h3&gt;vim中文乱码问题--本机设置&lt;/h3&gt;

&lt;p&gt;首先应该选用utf8格式的编码比较靠谱，同时为了防止乱码现象，应该保障系统设置和vim的设置相一致&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#echo $LANG //查看系统当前选用编码方式  
#LANG=zh_CN.utf8  
#vim /etc/vimrc  //将set fileencodings 设置如下  
set fileencodings=utf8,gbk,big5,ucs-bom,latin1  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;其他推荐的设置&lt;/h3&gt;

&lt;p&gt;中文环境GBK码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#LANG=zn_CN.gbk  
#vim /etc/vimrc  
set fileencodings=gbk,big5,ucs-bom,latin1  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中文环境UTF8参照之前的本机设置&lt;br/&gt;
英文环境就直接用就好了，所以推荐装机的时候就选择英文系统，毕竟码代码还是英文用的多点&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>utorrent+mplayer使用</title>
   <link href="http://perthcharles.github.com/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/2013/03/23/utorrentmplayer"/>
   <updated>2013-03-23T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/2013/03/23/utorrentmplayer</id>
   <content type="html">&lt;h3&gt;utorrent&lt;/h3&gt;

&lt;p&gt;为了在centos上面下载六维空间的资源，就必须选择一个给力的下载器，但是目前utorrent客户端只有WINDOWS版本，所以就必须曲线救国了。我的方法如下：&lt;br/&gt;
首先确保你添加了第三方的源，如果不会添加请移步&lt;a href=&quot;http://perthcharles.github.com/centos6.4/2013/03/18/yum-using/&quot;&gt;yum 源的使用&lt;/a&gt;&lt;br/&gt;
然后安装在linux环境下安装windows软件的平台，想了解更多的请&lt;a href=&quot;www.google.com&quot;&gt;google wine&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#yum installl wine  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装好wine环境后，只要下载一个windows环境下的utorrent.exe文件，就可以直接打开这个软件下载六维的软件了。开始享受吧！&lt;/p&gt;

&lt;h3&gt;mplayer使用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#yum list|grep mplayer  //查看你的源中是否有mplayer  
#mplayer [-fs] filename  //-fs是可选项，表示全屏播放  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要说明的是我的mplayer没有安装图形界面(自己懒的动)，所以只能选择在命令行下输入命令播放视频，不过够用就行。&lt;/p&gt;

&lt;h4&gt;无线网卡配置&lt;/h4&gt;

&lt;p&gt;目前笔记本的无线网络功能处于无效状态。同时目前还没有需求，所以就没有配置。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Bench 安装记录</title>
   <link href="http://perthcharles.github.com/benchmarks/2013/03/23/hp-bench"/>
   <updated>2013-03-23T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/benchmarks/2013/03/23/hp-bench</id>
   <content type="html">&lt;h3&gt;操作系统信息&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#uname -r  
2.6.32-220.el6.x86_64  
#cat /etc/issue  
CentOS release 6.2 (Final)  
#gcc -v  
Using built-in specs.  
Target: x86_64-redhat-linux  
Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-languages=c,c++,objc,obj-c++,java,fortran,ada --enable-java-awt=gtk --disable-dssi --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-1.5.0.0/jre --enable-libgcj-multifile --enable-java-maintainer-mode --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --disable-libjava-multilib --with-ppl --with-cloog --with-tune=generic --with-arch_32=i686 --build=x86_64-redhat-linux  
Thread model: posix  
gcc version 4.4.6 20110731 (Red Hat 4.4.6-3) (GCC)  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;MonetDB+tpc-h&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#tar -xjvf MonetDB-11.5.9.tar.bz2  
#`pwd`/configure --enable-monetdb5 --enable-sql --enable-optimize --with-java=/usr/lib/jvm/java-1.6.0  
//configure: error: OpenSSL library not found but required for MonetDB5  
#yum install openssl-devel  
//configure: error: PCRE library not found but required for MonetDB5  
#yum install pcre-devel pcre  
//configure: error: libxml2 library not found but required for MonetDB5  
#yum install libxml2-devel  
#make &amp;amp;&amp;amp; make install  

#monetdbd create MonetDB-data  
#monetdbd start MonetDB-data  
#monetdb create SF4  
#monetdb start SF4  
#monetdb release SF4  

#cd ./sql/benchmarks/tpch/dbgen  
#cp makefile.suite makefile  
#make  
#./dbgen -s 4 //produce 4G data for test  
#cd ..  
#vim load.sh  //change the following stuff  
SQL='mclient -l sql -d SF4'  
SF='dbgen'  
#vim run.all  //change the following stuff  
SQL=&quot;mclient -l sql -d SF4&quot;  
#vim .monetdb //add the defult user and password  
user=monetdb  
password=monetdb  
#cp -r dbgen DBGEN  //rename the folder for load.sh  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;voltdb+tpc-c&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#unzip voltdb-master.zip //get this file from github  
//add the EPEL yum source  
//and make sure the ant's version is 1.7 or later  
#ant dist  
#cd tests/test_apps/tpcc  
#./run.sh  //run the server  
#./run.sh client //run the client  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;memcached+britus&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//install libevent，download the file then  
#./configure --prefix=/usr &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install  
//install php and extensions  
#yum install php php-pecl-memcached php-pear-noarch  
//install memcached  
#./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install  
//start the memcached  
#/usr/local/bin/memcached -d -m 1024 -u root -l [your ip address] -p 12000 -c 1024 -P memcached.pid  
//if you want to stop memcached  
#kill `cat /home/zhongbin/HP-Bench/log/log-memcached.pid`  
//restart the apache  
#service httpd restart  
#./brutis -t tests/append.xml -x [your ip address]:12000 -o append -v  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;more tips&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//solution for PHP Fatal error: Call to undefined function posix_getppid()  
#install php-process  
//solution for function XXX is deprecated,in php  
#add a '@' before the deprecated function  
//solution for XML. Class DOMDocument missing  
#yum install php-xml.x86_64  
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>yum使用指南</title>
   <link href="http://perthcharles.github.com/centos6.4/2013/03/18/yum-using"/>
   <updated>2013-03-18T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/centos6.4/2013/03/18/yum-using</id>
   <content type="html">&lt;h3&gt;yum安装软件&lt;/h3&gt;

&lt;p&gt;当你想安装软件的时候，可能你只知道一个大概的名字或者你想确认你系统的yum源中是否存在该软件包，那么你就可以用下面的命令来查找确认&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #yum list |grep softname  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想知道你现在已经安装来哪些包，可以使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#rpm -qa | grep softname  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到软件对应的正确软件包名称之后，就可以使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#yum install softname  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来正确安装你需要的软件了&lt;/p&gt;

&lt;h4&gt;如果提示有依赖文件没找到（通常是库文件）,那么可以尝试使用&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#yum provides */miss-file-name*  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来看看哪些安装程序可能提供这样的库文件&lt;/p&gt;

&lt;h3&gt;添加源&lt;/h3&gt;

&lt;p&gt;如果你需要安装的软件在现有的源里没有，你就可以尝试添加一个新的源到你的系统里面。当然，你必须保证添加的源跟你的系统是一致的（比如都是64位，对应centos-6）&lt;br/&gt;
//更改系统yum源配置,以添加google源为例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#vim /etc/yum.repos.d/google.repo  
[google]  
name=Google - i386  
baseurl=https://dl.google.com/linux/rpm/stable/i386  
enabled=1  
gpgchech=1  
pgpkey=https://dl-ssl.google.com/linux/linux_signing_key.pub  
//之后你就可以在源里面找到之前你可能找不到的安装包，比如chrome  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要说明的是，上面google的源是对应32位系统的，如果你是64位系统你需要将stable后面改为x86_64.并且上面google的链接直接用浏览器应该是打不开的，也就是说你没法从浏览器里面看到这个源里面都有哪些安装包&lt;/p&gt;

&lt;p&gt;如果碰到提示需要GPG-KEY的时候，可以先上网找到对应的KEY的链接，然后输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#rpm --import url-to-the-key-you-needed  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在添加完多个源后，可以再装一个yum的插件让它自动选择最开的源进行下载安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#yum install yum-fastestmirror -y //-y 表示需要你确认的时候，默认选择yes 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于国内的用户来说，&lt;a href=&quot;http://mirrors.ustc.edu.cn&quot;&gt;中科大的源&lt;/a&gt;是不错的选择,&lt;a href=&quot;lug.ustc.edu.cn/wiki/mirrors/help/debian&quot;&gt;这里&lt;/a&gt;是相关的使用帮助。&lt;/p&gt;

&lt;h3&gt;安装单独的软件包&lt;/h3&gt;

&lt;p&gt;如果你不能按照安装chrome那样直接找到正确的源的话，可以尝试到提供rpm包索引的网站去查找相应的软件&lt;br/&gt;
推荐使用：&lt;a href=&quot;rpm.pbone.net&quot;&gt;pbone.net网站&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;常用第三方yum源&lt;/h3&gt;

&lt;p&gt;推荐三个常用的yum源:&lt;br/&gt;
&lt;a href=&quot;http://mirrors.fedoraproject.org/publiclist/EPEL/&quot;&gt;EPEL&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://pkgs.repoforge.org/rpmforge-release/&quot;&gt;rpmforge&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://download1.rpmfusion.org/&quot;&gt;rpmfusion&lt;/a&gt;&lt;br/&gt;
在系统安装完多个源之后，最好再安装一个小工具:&lt;a href=&quot;http://mirrors.ustc.edu.cn/centos/6.4/os/x86_64/Packages/yum-plugin-fastestmirror-1.1.30-14.el6.noarch.rpm&quot;&gt;fastestmirror&lt;/a&gt;帮助你自动找到下载最快的源&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>centos5.9使用记录</title>
   <link href="http://perthcharles.github.com/2013/03/11/232-centos59-using-log"/>
   <updated>2013-03-11T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/11/232-centos59-using-log</id>
   <content type="html">&lt;h3&gt;配置内网&lt;/h3&gt;

&lt;p&gt;更改文件：/etc/sysconfig/network-scripts/ifcfg-eth0&lt;br/&gt;
1,将dhcp改为static&lt;br/&gt;
2,添加IPADDR，NETMASK，GATEWAY，DNS等字段&lt;/p&gt;

&lt;h3&gt;配置外网连接&lt;/h3&gt;

&lt;p&gt;更改文件：/etc/resolv.conf,加入nameserver配置，然后重启网络服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#service network restart  
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>test search</title>
   <link href="http://perthcharles.github.com/2013/03/08/test-search"/>
   <updated>2013-03-08T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/08/test-search</id>
   <content type="html">

&lt;!--Google站内搜索开始--&gt;


&lt;p&gt;&lt;form method=get action=&quot;http://www.google.com/search&quot; target=&quot;_blank&quot;&gt;
&lt;input type=text name=q&gt;
&lt;input type=submit name=btnG value=&quot;搜索&quot;&gt;
&lt;input type=hidden name=ie value=utf-8&gt;
&lt;input type=hidden name=oe value=utf-8&gt;
&lt;input type=hidden name=hl value=zh-CN&gt;
&lt;input type=hidden name=domains value=&quot;perthcharles.github.com&quot;&gt;
&lt;input type=hidden name=sitesearch value=&quot;perthcharles.github.com&quot;&gt;
&lt;/form&gt;&lt;/p&gt;

&lt;!--Google站内搜索结束--&gt;

</content>
 </entry>
 
 <entry>
   <title>linux命令学习（四）</title>
   <link href="http://perthcharles.github.com/2013/03/08/linux-using-4"/>
   <updated>2013-03-08T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/08/linux-using-4</id>
   <content type="html">&lt;h3&gt;常用命令简介&lt;/h3&gt;

&lt;p&gt;cat:从第一行开始显示文件&lt;br/&gt;
tac:从最后一行开始显示文件&lt;br/&gt;
nl:显示的时候顺便显示行数&lt;br/&gt;
more:一页一页地显示文件内容&lt;br/&gt;
less：与more类似，但是支持向上翻页&lt;br/&gt;
head:只看头几行&lt;br/&gt;
tail:只看结尾几行&lt;br/&gt;
od:以二进制的方式读取文件内容（效果不太好，希望以后找到合适的工具）&lt;/p&gt;

&lt;h3&gt;一些更细节的解释&lt;/h3&gt;

&lt;p&gt;cat:是concatenate(连续)的简写&lt;br/&gt;
tail:如果想检测一个持续被写入的文件，可以输入下面的命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cat -f filename  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;-f&lt;/strong&gt;的含义是follow，是指將新增加(append)到文件的内容打印出来&lt;/p&gt;

&lt;hr /&gt;

&lt;h3&gt;用户能进入某个目录&lt;/h3&gt;

&lt;p&gt;让用户能够进入某个目录成为“可工作目录”的基本权限需求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;可使用的命令：例如cd等切换工作目录的命令  
目录所需权限：用户对这个目录至少需要有x权限  
额外需求：如果用户想要在这个目录内利用ls查阅文件名，则用户对此目录还要有r的权限  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;用户在某目录下读文件&lt;/h3&gt;

&lt;p&gt;用户在某个目录内读取一个文件的基本权限需求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;可使用的命令：例如cat,more,less等  
目录所需权限：用户对这个目录至少需要有x权限  
文件所选权限：用户对文件至少需要具有r的权限才行  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;用户修改文件&lt;/h3&gt;

&lt;p&gt;用户修改一个文件的基本权限需求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;可使用的命令：vim等  
目录所需权限：用户在该文件所在的目录至少需要x权限  
文件所需权限：用户对该文件至少要有r,w权限  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;其他注意&lt;/h4&gt;

&lt;p&gt;让一个用户可以创建一个文件的基本权限要求是用户在该目录要有w,x的权限&lt;br/&gt;
让用户进入某目录并执行该目录下的某个命令的基本权限要求是用户对目录和对应文件都至少要有x的权限&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>linux命令学习（三）</title>
   <link href="http://perthcharles.github.com/2013/03/08/linux-using"/>
   <updated>2013-03-08T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/08/linux-using</id>
   <content type="html">&lt;h3&gt;关于pwd&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#cd /var/mail   
#pwd    //显示当前完整路径  
/var/mail  
#pwd -P //显示当前真实路径，而非使用链接的路径  
/var/spool/mail  
#ls -al  
（前面略去...）/var/mail -&amp;gt; /var/spool/mail  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;当一个文件夹是一个链接文件时，上述两个命令的执行结果会出现上例中的不同&lt;/p&gt;

&lt;h3&gt;创建多层目录&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#mkdir test/test  
mkdir: cannot create directory `test/test`: No such file or directory  
#mkdir -p test/test  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数&lt;strong&gt;-p&lt;/strong&gt;將帮助你把不存在的上层目录建立起来&lt;br/&gt;
mkdir还有-m参数：手动配置文件属性，而不用默认值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;关于属性：r=4,w=2,x=1,故7=4+2+1表示具有可读可写可执行的权限  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;简易随机数&lt;/h3&gt;

&lt;p&gt;如果想生成一个随机数，linux环境下可以简单的输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#echo $RANDOM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这样的范围是在0～32767之间，如果想生成一个在某个范围之内的随机数呢？这里将用到命令bc完成任务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#echo $RANDOM*10/32767 | bc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先通过echo命令完成计算表达式，然后用bc计算出来&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>linux命令学习（二）</title>
   <link href="http://perthcharles.github.com/2013/03/05/linux-using"/>
   <updated>2013-03-05T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/05/linux-using</id>
   <content type="html">&lt;h3&gt;本地帮助文件&lt;/h3&gt;

&lt;p&gt;一般系统安装（yum、spt-get、手动）软件后，都会有一些帮助你使用或理解的文件，除了REAMME之外，还可以查看一个路径获得有更多信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cd /usr/share/doc/  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;whatis = man -f&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#whatis date  
date (1)             - print or set the system date and time  
#mam -f date  
date (1)             - print or set the system date and time  
更多请查看：  
#man man  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;关机前检查&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#who      //查看现在都有谁在线  
#netstat  //查看网络的联机状态  
#ps -aux  //查看后台程序  
#reboot   //重启电脑  
#shutdown -h now //立即关机  
#shutdown -r now //立即重启  
#shutdown -h 10  //10分钟后关机  
#poweroff           //断电关机  
#init 0          //执行等级设置为关机  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;linux常见目录及其含义&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#/  
    根目录(root)  
#/usr  
    软件存放位置(Unix Software Resource)  
#/etc  
    配置文件  
#/opt  
    第三方软件  
    更多的情况是会装到**/usr/local/**目录下  
#/boot  
    开机与内核文件  
    主要包括：Linux内核文件以及开机菜单和开机所需配置文件等  
    linux kernel常用的文件名为vmlinuz  
#/boot/grub  
    如果使用grub引导装载程序，会存在这个文件夹  
#/var  
    与系统运作过程有关  
#/bin  
    放置的是在单用户模式下**还**能够被操作的命令  
    主要有cat chmod chown date mv mkdir cp bash等常用命令   
#/dev  
    任何设备与接口设备都是以文件的形式存在于这个目录之中  
#/lib  
    放置开机时会用到的函数库  
    **/lib/modules**会放置内核相关的模块(驱动程序)  
#/media  
    放置可删除的设备  
#/mnt  
    如需临时挂载设备，建议挂载到这个目录下面  

#/sbin(system binary)  
    放置包括开机，修复，还原系统所需的命令。常见的有：fdisk,fsck,ifconfig,init,mkfs  
#/usr/sbin      服务器软件程序  
#/usr/local/sbin    自行安装的软件  

#/srv(service)  
    常见的有网络服务WWW，FTP  

#/lost+found  
    当文件系统发生错误时 ，將一些丢弃的片段放置到这个目录下  
    目录通常会在分区的最顶层  
#/proc  
    其实是虚拟文件系统，放置的内容都在内存中，不占用实际的硬盘空间  
#/sys   与/proc文件夹类似  
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>linux命令学习(一)</title>
   <link href="http://perthcharles.github.com/2013/03/01/linux-using"/>
   <updated>2013-03-01T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/01/linux-using</id>
   <content type="html">&lt;h2&gt;查找软件安装位置方法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#whereis name-of-software  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;查看通过yum已安装的程序&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#rpm -qa |grep 程序名  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;du读取文件大小&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#man du  
#du -h  //自动的用更易读的方法输出结果  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;xargs（好用）&lt;/h2&gt;

&lt;p&gt;xargs能够將上一个命令的执行结果当作参数传递给下一个命令。忘记细节了，请记得：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#man xargs  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举例：將find找到的文件，传递给du命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#find /etc -name *id.conf |xargs du -h  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;删除文件夹内全部文件&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#rm -f *  //-f意味着不一一提示是否删除  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：当文件夹没文件过多或文件名长度过长，会导致&lt;em&gt;argument list too long&lt;/em&gt;的错误，我理解的原因就是正则式“*”展开导致命令行长度过长。这是UNIX以来就有的限制。查看限制可使用命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#getconf ARG_MAX  //我的电脑是2097152  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除所有文件：执行ls得到文件夹所有文件的路径，xargs將ls的输出，每10个一组（以空格为分割符）作为rm -rf 的参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ls |xargs -n 10 rm -rf  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除符合特定命名的文件,其实多少个一组是可选的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#find -name XXX |xargs [-n 10] rm -rf  
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>linux常用工具列表</title>
   <link href="http://perthcharles.github.com/linux-learning/2013/03/01/linux-tools"/>
   <updated>2013-03-01T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/linux-learning/2013/03/01/linux-tools</id>
   <content type="html">&lt;h3&gt;常用工具列表&lt;/h3&gt;

&lt;p&gt;git&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#git add *
#git commmit -a -m &quot;commit-name&quot;
#git push origin master
#git clone XXX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;retext&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#retext filename  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;xsel&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cat filename |xsel -b -i  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;goagent&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#python proxy.py  
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>linux系统信息</title>
   <link href="http://perthcharles.github.com/linux-learning/2013/03/01/linux-system-info"/>
   <updated>2013-03-01T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/linux-learning/2013/03/01/linux-system-info</id>
   <content type="html">&lt;h1&gt;系统信息相关&lt;/h1&gt;

&lt;h4&gt;查看系统发行版本号&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#cat /etc/issue
#lsb_release -a
#cat /etc/redhat-release(针对redhat,Fedora)  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;查看内核版本等信息&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#uname -a //a 表示 all  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多信息：&lt;a href=&quot;http://xiaozhen1900.blog.163.com/blog/static/17417325720115713351300/&quot;&gt;查看LINUX发行版的名称及其版本号的命令&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;linux下文件编码格式转换方法&lt;/h4&gt;

&lt;p&gt;推荐工具：enca&lt;br/&gt;
安装方法ubuntu：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#sudo apt-get install enca  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#enca -L zh_CN file  //检查file的编码
#enca -L zh_CN -x UTF-8 file //將file转换为UTF-8编码格式  
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>初识Jekyll</title>
   <link href="http://perthcharles.github.com/tools/2013/02/25/First-view-of-Jekyll"/>
   <updated>2013-02-25T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/tools/2013/02/25/First-view-of-Jekyll</id>
   <content type="html">&lt;h2&gt;关于 Jekyll&lt;/h2&gt;

&lt;p&gt;首先，Jekyll不是一个博客软件，更加准确的说法应该是一个解析器。当你按照Jekyll事先定义好的规则写好了一篇博客后，它会自动的將对应文件解析成最终的博客样式。&lt;/p&gt;

&lt;h2&gt;关于Page&lt;/h2&gt;

&lt;p&gt;Pages支持较多文件类型，我主要用MARKDOWN和HTML这两种文件类型。任何根目录下和不是以下划线开始的子文件夹下的Page文件都能够被Jekyll自动解析。&lt;/p&gt;

&lt;h2&gt;关于Post&lt;/h2&gt;

&lt;p&gt;新建一个post可以用下面的命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#rake post title=&quot;name of post&quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样产生的文件会在文件夹：_posts下，且后缀名为：&lt;strong&gt;md&lt;/strong&gt;&lt;br/&gt;
注意：后缀名不能为MARKUP，否则jekyll不能正确解析post文件&lt;/p&gt;

&lt;h2&gt;Categories和Tags&lt;/h2&gt;

&lt;p&gt;这两个功能只能针对post生效，对page没有作用。具体的用法是在post文件的最开始定义好这些内容。如这篇post对应的定义内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
title: 初识Jekyll
category : tools
tags : jekyll
---  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种定义形式叫做：YAML Front Matter，更多细节解释请查看&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front Matter&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;关于themes&lt;/h2&gt;

&lt;p&gt;现在用的主题名为：the program,安装方法为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#rake theme:install git=&quot;https://github.com/jekyllbootstrap/theme-the-program.git&quot;  
#rake theme:switch name=&quot;the-program&quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;我的posts列表样例&lt;/h2&gt;

&lt;ul class=&quot;posts&quot;&gt;
  
    &lt;li&gt;&lt;span&gt;13 Apr 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/papars/2013/04/13/trace-driven-survey&quot;&gt;Trace驱动的memory模拟：综述&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;12 Apr 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/04/12/linux-using&quot;&gt;linux 命令学习（五）&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;28 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/28/x-window&quot;&gt;X window&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;25 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/25/linux-disassemble&quot;&gt;linux 反汇编初步&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;25 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/25/gnu-as-pratice&quot;&gt;Gnu AS 汇编实践&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;24 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/24/ssh-free-pwd&quot;&gt;ssh免密码登录&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;24 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/%E9%9D%A2%E8%AF%95%E9%A2%98/2013/03/24/negation-in-c&quot;&gt;一道C语言二进制反码题&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;24 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/24/install-linux-from-disk&quot;&gt;硬盘安装linux&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;24 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/centos6.4/2013/03/24/centos-mount-ntfs&quot;&gt;在centos系统下，挂在ntfs格式的磁盘分区&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;23 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/23/vim-decode&quot;&gt;vim 编码相关问题&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;23 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/2013/03/23/utorrentmplayer&quot;&gt;utorrent+mplayer使用&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;23 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/benchmarks/2013/03/23/hp-bench&quot;&gt;Bench 安装记录&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;18 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/centos6.4/2013/03/18/yum-using&quot;&gt;yum使用指南&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;11 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/11/232-centos59-using-log&quot;&gt;centos5.9使用记录&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;08 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/08/test-search&quot;&gt;test search&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;08 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/08/linux-using-4&quot;&gt;linux命令学习（四）&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;08 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/08/linux-using&quot;&gt;linux命令学习（三）&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;05 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/05/linux-using&quot;&gt;linux命令学习（二）&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;01 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/01/linux-using&quot;&gt;linux命令学习(一)&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;01 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/linux-learning/2013/03/01/linux-tools&quot;&gt;linux常用工具列表&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;01 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/linux-learning/2013/03/01/linux-system-info&quot;&gt;linux系统信息&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;25 Feb 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/tools/2013/02/25/First-view-of-Jekyll&quot;&gt;初识Jekyll&lt;/a&gt;&lt;/li&gt;
  
&lt;/ul&gt;


&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://jiyeqian.github.com/2012/07/host-your-pages-at-github-using-jekyll/&quot;&gt;基于jekyll的github建站指南&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://twitter.github.com/bootstrap/&quot;&gt;Bootstrap官网&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://liquidmarkup.org/&quot;&gt;Liquid官网&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://www.mceiba.com/develop/liquid-learn.html&quot;&gt;使用Liquid模板语言&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://jekyllbootstrap.com/&quot;&gt;Zero to Hosted Jekyll Blog in 3 Minetes&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://www.soimort.org/posts/101/&quot;&gt;像黑客一样写博客--Jekyll入门&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 
</feed>