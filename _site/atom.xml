<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>My blog</title>
 <link href="http://perthcharles.github.com/" rel="self"/>
 <link href="http://perthcharles.github.com"/>
 <updated>2013-05-26T15:12:48+08:00</updated>
 <id>http://perthcharles.github.com</id>
 <author>
   <name>Perth Charles</name>
   <email>zhongbincharles@gmail.com</email>
 </author>

 
 <entry>
   <title>POJ上看到一种O(nm)求逆序数的方法</title>
   <link href="http://perthcharles.github.com/2013/05/22/inverse-number"/>
   <updated>2013-05-22T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/05/22/inverse-number</id>
   <content type="html">&lt;h1&gt;思路其实很简单，直接上代码&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;int count_inver(char *str, int len)
{
        int i;  
        int cnt = 0;
        int a[4] = {0};
        for(i = len - 1; i &amp;gt;= 0; i--) {
                switch (str[i]) {
                        case 'A':
                                a[1]++; 
                                a[2]++; 
                                a[3]++; 
                                break;  
                        case 'C':
                                a[2]++; 
                                a[3]++; 
                                cnt += a[1];
                                break;  
                        case 'G':
                                a[3]++; 
                                cnt += a[2];
                                break;  
                        case 'T':
                                cnt += a[3];
                }
        }
        return cnt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;算法分析&lt;/h1&gt;

&lt;p&gt;时间复杂度是O(mn)，其中m表示所有可能出现元素的个数，比如上例只可能出现“A,C,G和T”，那么m=4，而n表示该字符串的长度。由于m一般来讲比n小很多，所以这种以空间换时间的算法还是挺有效果的。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>javascript quick learning</title>
   <link href="http://perthcharles.github.com/2013/05/17/javascript-quick-learning"/>
   <updated>2013-05-17T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/05/17/javascript-quick-learning</id>
   <content type="html">&lt;p&gt;字符串：&quot;perth charles&quot;&lt;br/&gt;
求字符串长度：&quot;perth charles&quot;.length&lt;/p&gt;

&lt;p&gt;&quot;cake&quot;.length * 9&lt;br/&gt;
confirm(&quot;you must be kidding me!\n&quot;);  弹出窗口让用户确认某些信息
prompt(&quot;what is your name?&quot;)； 弹出窗口接受用户输入
console.log(&quot;Hello&quot;);   相当与printf语句&lt;/p&gt;

&lt;p&gt;注意这两个比较操作符
=== Equal to
!== Not equal to&lt;/p&gt;

&lt;p&gt;&quot;wonderful day&quot;.substring(3,7);     输出字符的第4位到第7位&lt;/p&gt;

&lt;p&gt;声明三种变量
a. var myName = &quot;Leng&quot;;
b. var myAge = 30;
c. var isOdd = true;&lt;/p&gt;

&lt;p&gt;// This is what a function looks like:
var divideByThree = function (number) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var val = number / 3;
console.log(val);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;};  //注意这个地方也有分号&lt;/p&gt;

&lt;p&gt;生成一个0到1之间的随机数，如一次结果为：0.8760658339597285
var computerChoice = Math.random();&lt;/p&gt;

&lt;p&gt;//检测x的类型
typeof(x) ！== 'number'&lt;/p&gt;

&lt;p&gt;// Example of a for loop:
for (var counter = 1; counter &amp;lt; 6; counter++) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log(counter);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;数组/列表
var arrayName = [data, data, data];
arrayName.length    //求数组/列表 长度
arrayName.push();   //给列表添加元素&lt;/p&gt;

&lt;p&gt;isNaN() //判断是否是一个数&lt;/p&gt;

&lt;p&gt;逻辑运算符跟C一样&lt;/p&gt;

&lt;p&gt;//一个对象的例子
var phonebookEntry = {};
phonebookEntry.name = 'Oxnard Montalvo';
phonebookEntry.number = '(555) 555-5555';
phonebookEntry.phone = function() {
  console.log('Calling ' + this.name + ' at ' + this.number + '...');
};
phonebookEntry.phone();&lt;/p&gt;

&lt;p&gt;//又一个典型的对象声明例子
var friends = {};//相当与一个对象列表？
friends.bill = {
  firstName: &quot;Bill&quot;,
  lastName: &quot;Gates&quot;,
  number: &quot;(206) 555-5555&quot;,
  address: ['One Microsoft Way','Redmond','WA','98052']
};&lt;/p&gt;

&lt;p&gt;friends.steve = {
  firstName: &quot;Steve&quot;,
  lastName: &quot;Jobs&quot;,
  number: &quot;(408) 555-5555&quot;,
  address: ['1 Infinite Loop','Cupertino','CA','95014']
};&lt;/p&gt;

&lt;p&gt;//一个更加复杂的例子
/*
var friends = {};
friends.bill = {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;firstName: &quot;Bill&quot;,
lastName: &quot;gates&quot;,
number: &quot;20&quot;,
address: [&quot;beijing&quot;, &quot;china&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;};
friends.steve = {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;firstName: &quot;Steve&quot;,
lastName: &quot;dddddd&quot;,
number: &quot;22&quot;,
address: [&quot;shanghai&quot;, &quot;china&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;};
var list = function(){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(var example in friends){
    console.log(example);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;};&lt;/p&gt;

&lt;p&gt;var search = function(name){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(var entity in friends){
    if(friends[entiry].firstName === name){
        console.log(friends[entiry]);
        return friends[entity];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;};
*/&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>中国剩余定理</title>
   <link href="http://perthcharles.github.com/%E9%9D%A2%E8%AF%95%E9%A2%98/2013/05/14/chinese_remainder_theorem"/>
   <updated>2013-05-14T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/%E9%9D%A2%E8%AF%95%E9%A2%98/2013/05/14/chinese_remainder_theorem</id>
   <content type="html">&lt;h2&gt;问题&lt;/h2&gt;

&lt;p&gt;一个整数除以三余二，除以五余三，除以七余二，求最小的满足条件的整数&lt;/p&gt;

&lt;h2&gt;要点&lt;/h2&gt;

&lt;p&gt;各个除数之间要互质&lt;/p&gt;

&lt;h2&gt;解法要点&lt;/h2&gt;

&lt;p&gt;求出5和7的最小公倍数35的倍数中除以3余数为1的最小一个70（这个称为35相对于3的数论倒数），3和7的最小公倍数21相对于5的数论倒数21，3和5的最小公倍数15相对于7的数论倒数15，然后&lt;br/&gt;
$$70\times 2+21\times 3+15\times 2=233$$&lt;br/&gt;
但这求出的并不是最小值，因为35%3已经等于2了，所以最终的求解算法应该是：&lt;br/&gt;
$$n=\left( a\ast 10+b\ast 4+c\ast 15\right) \%105$$&lt;br/&gt;
求模是因为如果存在一个比105大的可行解，则必然存在一个比105小的可行解。
然后根据题目要求确定满足条件的n。&lt;/p&gt;

&lt;h2&gt;C代码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;

//get_m()的作用就是求a*b 相对与c 的数论倒数
int get_m(int a, int b, int c)
{
    int ab, ab_r;
    int i, j;
    ab = a*b;
    ab_r = ab%c;
    j = ab;
    for(i = 0; i &amp;lt; c; i ++){
        if(ab % c == 1)
            return ab;
        else
            ab += j;
    }
    return -1;
}

int main()
{
    int a, b, c, n;
    int a_r, b_r, c_r;  //a_r是n%a的余数
    int a_m, b_m, c_m;  //a_m是(b*c)相对与a的数论倒数
    scanf(&quot;%d %d %d&quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
    if(a*b*c == 0){
        printf(&quot;you must be kidding me!\n&quot;);
        return 0;
    }
    scanf(&quot;%d %d %d&quot;, &amp;amp;a_r, &amp;amp;b_r, &amp;amp;c_r);
    if((a_m = get_m(b, c, a)) != -1 &amp;amp;&amp;amp; (b_m = get_m(a, c, b)) != -1 &amp;amp;&amp;amp; (c_m = get_m(a, b, c)) != -1){
        printf(&quot;n is:%d\n&quot;, (a_m*a_r + b_m*b_r + c_m*c_r) % (a*b*c));
        return 0;
    }
    else{
        printf(&quot;Can not find an answer!\n&quot;);
        return 0; 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86&quot;&gt;中国剩余定理&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>交互式程序性能评测</title>
   <link href="http://perthcharles.github.com/Papers/2013/05/11/"/>
   <updated>2013-05-11T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/Papers/2013/05/</id>
   <content type="html">
</content>
 </entry>
 
 <entry>
   <title>linux命令学习(七)：grep高级用法与正则表达式初步</title>
   <link href="http://perthcharles.github.com/2013/05/09/linuxgrep"/>
   <updated>2013-05-09T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/05/09/linuxgrep</id>
   <content type="html">&lt;h2&gt;grep 高级用法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#grep -An -Bm -n -v  [--color=auto] '搜索字符串' filename
-An 输出找到行之后的n行
-Bm 输出找到行之前的m行
//复习之前的用法
-n  附带输出相应行号
-v  反向选择
-i  忽视大小写

//为了让找到的字符串自动加上颜色，修改~/.bashrc,添加如下命令
alias grep='grep --color=auto'
//使更改后的文件生效
#source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2&gt;关于正则表达式需要注意的点&lt;/h2&gt;

&lt;p&gt;1.处理单元是行&lt;br/&gt;
2.正则表达式的结果可能收到不同语系编码的影响&lt;br/&gt;
3.如需查找具有特殊含义的符号，需要使用转义字符'\'&lt;/p&gt;

&lt;h3&gt;集合[]用法&lt;/h3&gt;

&lt;p&gt;[]中可以包含多个字符，如[abcd]。含义为:出现abcd四个中的任意一个都可以，而且出现且仅出现一次。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#grep 't[ab]st' filename    //找出filename中所有的tast和tbst串
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;^反选符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#grep '[^g]oo' filename     //找出filename中所有包含'oo'字符串且'oo'前面不是字符g的出现
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-连续出现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#grep '[a-z]oo' filename    //找出filename中所有以a到z的字符开始后接oo的出现
#grep '[[:lower:]]' filename    //效果与上句类似，但是排除了语系不同可能带来的干扰
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;行首与行尾字符^$&lt;/h3&gt;

&lt;p&gt;行首字符'^',这点要与集合[]中出现的^区别开&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#grep -n 'the' filename     //找出filename中所有以the开始的行
#grep -n '\.$' filename     //找出filename中所有以'.'结束的行
#grep -n '^$' filename      //找出空白行
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;任意一个字符和重复字符(. 和 *)&lt;/h3&gt;

&lt;p&gt;'.'表示有且仅有一个字符&lt;br/&gt;
'&lt;em&gt;'表示重复0个或多个前面的字符，这点与通配符(表示任意个字符)'&lt;/em&gt;'需要区分开&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#echo o |grep 'oo*' //如果按照通配符的理解，至少需要两个oo后接任意个字符,但实际上这条命令的含义是找到至少含有一个o，且后面跟0个o或多个o的所有字符串
//下面命令的含义是：找到字符串开头和结尾都是g，且两个g之间只能存在字符o，且至少有一个
#grep -n '^goo*g$' filename
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;sed命令用法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#sed [-nefi] [action]
-n  仅输出经过特殊处理的那些行到屏幕
-e  直接在命令行模式下进行sed动作的编辑
-f  直接将sed的动作写在一个文件内 -f filename
-i  直接修改读取的文件内容，而不是由屏幕输出
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;sed命令很强大，也很繁琐。所以这里不罗嗦直接上我练习的几个命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#nl /etc/passwd | sed  '2a drink tea' |sed '4a drink tea, too' |grep -A3 -B3 'drink tea'            //在第2行和第4行添加相应内容
#nl /etc/passwd | sed  '2a drink tea' |sed '4a drink tea, too' |sed -n '2,5p' |grep -A3 -B3 'drink tea'     //在上一条的基础上只显示2-5行数据
#nl /etc/passwd | sed  '2a drink tea' |sed '4a drink tea, too' |sed 's/drink/drinking/g' |grep -A3 -B3 'drink.* tea'    //将drink替换为drinking
#ifconfig eth0 |grep 'inet addr' |sed 's/^.*addr://g' |sed 's/Bcast.*$//g'  //用两次替换，将电脑的IP地址从ifconfig中抽取出来
#ifconfig eth0 |grep '9' |sed 's/^.*addr://g' |sed 's/Bcast.*$//g' |sed '/^.*X.*$/d'    //删除特定的行，显示IP地址
#ifconfig eth0 |grep '9' |sed 's/^.*addr://g' |sed 's/Bcast.*$//g' |sed 's/^.*X.*$//g' |sed '/^$/d'     //将某些特定的行替换为空行，并删除
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;awk命令&lt;/h3&gt;

&lt;p&gt;awk对比sed：awk主要针对行内数据进行操作，sed主要是以行为单位进行操作&lt;br/&gt;
命令语法格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#awk '条件类型1{动作1} 条件类型2{动作2} ...' filename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;awk过于复杂，所以以后慢慢练习。&lt;/p&gt;

&lt;h3&gt;其他好用命令：&lt;/h3&gt;

&lt;p&gt;diff+patch:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;diff用来比较两个文件的差别(虽然我基本都用vimdiff)，如果结合patch命令还能完成版本管理的一部分功能呢。命令如下：
#last &amp;gt; last.text   //生成一个文件
#cat last.text | sed '3,5d' |sed '$d' &amp;gt; last.text2  //生成一个*更新*的文件
#diff -Naur last.text last.text2 &amp;gt; last.patch       //比较两个文件
#ll last.text*  
-rw-rw-r--. 1 zhongbin zhongbin 29298 May 21 15:28 last.text
-rw-rw-r--. 1 zhongbin zhongbin 29030 May 21 15:30 last.text2
#patch -p0 &amp;lt; last.patch //更新，将旧文件按照diff的结果更新到新的文件
#ll last.text*
-rw-rw-r--. 1 zhongbin zhongbin 29030 May 21 15:33 last.text
-rw-rw-r--. 1 zhongbin zhongbin 29030 May 21 15:30 last.text2
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>linux命令学习(六)：cut grep && || sort wc uniq</title>
   <link href="http://perthcharles.github.com/2013/05/08/cut-and-grep"/>
   <updated>2013-05-08T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/05/08/cut-and-grep</id>
   <content type="html">&lt;h2&gt;命令执行时的判断依据&lt;/h2&gt;

&lt;p&gt;在一行中执行多条命令可能用到的用法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//不管cmd1是否执行成功，都会执行cmd2. 就是依次执行cmd1和cmd2
#cmd1;cmd2

//若cmd1执行完成并正确执行，则开始执行cmd2；若执行出错则跳过cmd2
#cmd1 &amp;amp;&amp;amp; cmd2

//若cmd1执行完成并正确执行，则跳过cmd2；若执行出错则执行cmd2
#cmd1 || cmd2
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2&gt;选取命令：cut、grep&lt;/h2&gt;

&lt;h3&gt;cut用法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#cut -d '分隔符' -f fields  &amp;lt;== 用于分隔字符
#cut -c 字符范围            &amp;lt;== 用于处理排列整齐的信息
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;cut参数解释&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;-d 后面跟分隔符，与-f一同使用
-f 后面跟需要取出来的段号，从1开始计数
-c 以字符为单位取出固定字符区间
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;cut使用举例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//各段之间以'：'来分隔，命令取出第3和第5段
#echo $PATH | cut -d ':' -f 3,5

//用last在显示的登录者信息中仅留下用户名
#last | cut -d ' ' -f 1

//去掉export命令执行结果中每行的'declare -x '
#export |cut -c 12-
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;cut使用总结&lt;/h3&gt;

&lt;p&gt;cut的主要用途是以行为单位进行数据分解，对有固定格式的行尤其有效&lt;/p&gt;

&lt;hr /&gt;

&lt;h3&gt;grep用法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#grep [-acinv] [--color=auto] '待查找字符串' filename
参数解释：
-a 将binary文件以text文件的方式查找数据
-c 计算找到符合条件的字符串的次数
-i 忽略大小写
-n 顺便输出行号
-v 反向选择
-r recursive递归的查找，用于文件夹中还有文件夹的情形
--color=auto 可以将找到的关键字部分加上颜色显示
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;grep举例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#last |grep 'root'
#last |grep -v 'root'
#last |grep 'root' |cut -d ' ' -f 1
#grep 'MANPATH' /etc/man.config

//在文件夹中找寻所有包含'include'的文件
#grep -r 'include' *
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2&gt;sort参数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;-f 忽视大小写
-b 忽视每行最前面的空格
-n 以纯数字进行排序
-r 反向排序
-u 相同数据仅出现一个代表
-t 指定分隔符，默认为Tab
-k 指定排序field
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;举例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#cat /etc/passwd |sort
#cat /etc/passwd |sort -t ':' -k 3
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;uniq 和wc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#uniq [-ic]
-i 忽视大小写
-c 进行计数

#wc [-lwm]
-l 以行为单位
-w 以单词为单位
-m 以字符为单位
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;更多文本处理命令tr col join paste expand split&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#last |tr '[a-z]' '[A-Z]'   //转换所有小写字母到大写
#cat /etc/passwd |tr -d ':' //删除输出信息中的':'

#col -x             //将tab扩展为空格

#man col |col -b &amp;gt; /root/col.man    //将man文件转为文本文件方便查阅

#paste -d ':' file1 file2       //将两个文件同一行粘帖在一起，如果file位置为'-',则表示输入来自standant input

#expand [-t num] file           //将file的tab转为num数量的空格

#split -b 300k file PREFIX      //将file文件切成大小为300k的文件组
#ls -al |split -l 10 - lsroot       //将ls执行结果以10行为单位存成文件
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>kvm qemu环境搭建</title>
   <link href="http://perthcharles.github.com/2013/04/27/kvm-qemu"/>
   <updated>2013-04-27T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/04/27/kvm-qemu</id>
   <content type="html">&lt;h3&gt;主要用到软件&lt;/h3&gt;

&lt;p&gt;vnc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#yum install vnc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;kvm&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//检查CPU是否支持kvm，输出为空表示不支持
#egrep '(vmx|svm)' /proc/cpuinfo
//安装kvm
#yum install kvm kmod-kvm qemu kvm-qemu-img virt-viewer virt-manager
or
#yum groupinstall KVM  //我选用这种命令 :)
//检查模块是否加载
#lsmod |grep kvm
//应该有以下输出
kvm_intel             xxxxxx  0 
kvm                   xxxxxx  1 kvm_intel
//如果没有上面两个模块，尝试
#modprobe kvm
#modprobe kvm-intel
//还是检查kvm是否安装成功,祈祷不要得到erroe信息吧:)
#virsh -c qume:///system list
//如果遇到error:unable connect ...libvirtd...,尝试一般是因为没有启用libvirtd服务，使用命令
#service libvirtd restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;qume&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#yum install qemu
//note:我服务器没能正确执行这条命令，用下面命令发现, so...
#yum list |grep qemu
kvm-qemu-img.x86_64 ... installed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;创建一台虚拟机器&lt;/h3&gt;

&lt;p&gt;如果不明白下面命令的含义，请查看man :) &lt;br/&gt;
1.创建一块虚拟硬盘&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#qemu-img create -f qcow2 disk.img 20G
or
#dd if=/dev/zero of=disk.img bs=1G count=5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.在虚拟硬盘中安装操作系统&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#qemu-kvm -enable-kvm -m 2024 -hda disk.img -cdrom win7XXXX.iso -boot d  //内存设置为2G
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4&gt;可能遇到问题&lt;/h4&gt;

&lt;p&gt;a.如果你遇到qemu-kvm命令不存在的情况，可能是因为：&lt;br/&gt;
从 6 系列开始 RedHat 推荐使用 virt-install/virsh 系列工具操作 kvm，而不是直接使用 qemu-kvm，所以 qemu-kvm 被移到一个不起眼的地方 /usr/libexec/，这点可以通过命令确认一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#yum provides */qemu-kvm
//在filename位置会发现：/usr/libexec/qemu-kvm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;针对这个问题，可以建立一个链接&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ln -sf /usr/libexec/qemu-kvm /usr/bin/qemu-kvm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;b.qemu-kvm could not initialize sdl - exiting&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//尝试方法一：
加入-no-quit选项，忽略SDL窗口的退出(无效)
//最后发现是我的xshell中没有对这台服务器选用x window功能 :(
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;c.vncviewer连接问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;据说是vnc的bug，在连接的时候加上AutoSelect=0就好了。
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;3.运行一个虚拟机&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//后台启动虚拟机
#qemu-kvm -m 2048 -hda win7.img -k en-us -vnc 127.0.0.1:29 -daemonize -redir tcp:3389::3389
//connect via vnc
#vncviewer localhost:29 AutoSelect=0
//connect via rdesktop, 必须首先通过设置开启远程链接服务
#rdesktop localhost
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;运行多个虚拟机&lt;/h3&gt;

&lt;p&gt;从网上找了不少资料，但是配置bridge和tap总是出现问题，最后改用virtual manager来管理，就挺顺利的&lt;/p&gt;

&lt;p&gt;1.确保系统中安装了libvirt&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#yum list |grep libvirt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.使用脚本安装系统&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cat win7.sh
virt-install \
--name win7 \
--ram 2048 \
--vcpus=1 \
--disk path=win7.img,size=20 \
--accelerate \
--cdrom win7.iso \
--vnc \
--keymap=en-us
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体参数可能会略有不同，详情请查看man virt-install&lt;br/&gt;
3.在虚拟机中开启远程桌面连接功能&lt;br/&gt;
4.查看虚拟机ip地址&lt;br/&gt;
5.用rdesktop连接到虚拟机&lt;/p&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>x window学习笔记</title>
   <link href="http://perthcharles.github.com/x%20window%20%E5%AD%A6%E4%B9%A0/2013/04/26/x-window"/>
   <updated>2013-04-26T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/x%20window%20%E5%AD%A6%E4%B9%A0/2013/04/26/x-window</id>
   <content type="html">&lt;h3&gt;常用函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;1.Display *XOpenDisplay(char *display_name);  
用途:connect to X server  
参数display_name指明将X window窗口显示到哪个硬件(Specifies the hardware display name)。为空(NULL)时,默认值为当前系统的DISPLAY环境变量。  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详见:&lt;a href=&quot;http://www.x.org/releases/X11R7.5/doc/man/man3/XOpenDisplay.3.html&quot;&gt;http://www.x.org/releases/X11R7.5/doc/man/man3/XOpenDisplay.3.html&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2.Window XCreateWindow(Display *display, Window parent, int x, int y, unsigned int width, unsigned int height, unsigned int border_width, int depth, unsigned int class, Visual *visual, unsigned long valuemask, XSetWindowAttributes *attributes);  
The XCreateWindow function creates an unmapped subwindow for a specified parent window, returns the window ID of the created window, and causes the X server to generate a CreateNotify event. The created window is placed on top in the stacking order with respect to siblings.  
The created window is not yet displayed (mapped) on the user's display. To display the window, call XMapWindow. The new window initially uses the same cursor as its parent. A new cursor can be defined for the new window by calling XDefineCursor. The window will not be visible on the screen unless it and all of its ancestors are mapped and it is not obscured by any of its ancestors.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详见:&lt;a href=&quot;http://www.x.org/releases/X11R7.5/doc/man/man3/XCreateSimpleWindow.3.html&quot;&gt;http://www.x.org/releases/X11R7.5/doc/man/man3/XCreateSimpleWindow.3.html&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3.int XMapWindow(Display *display, Window w);
The XMapWindow function maps the window and all of its subwindows that have had map requests. Mapping a window that has an unmapped ancestor does not display the window but marks it as eligible for display when the ancestor becomes mapped. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详见:&lt;a href=&quot;http://www.x.org/releases/X11R7.5/doc/man/man3/XMapWindow.3.html&quot;&gt;http://www.x.org/releases/X11R7.5/doc/man/man3/XMapWindow.3.html&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;简单用法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Display* display = XOpenDisplay(NULL);
Window win = XCreateSimpleWindow(display, RootWindow(display, screen), 0, 0, width, height, 3, BlackPixel(display, screen), WhitePixel(display, screen));
XMapWindow(display, win);//完成这一步才会最终在显示器上显示窗口
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;基本流程&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;建立一个 display至 X Server  
取得 display的相关资料  
建立视窗  
和视窗管理程式(Window Manager)沟通  
显示视窗  
关闭(destroy)视窗  
关闭 display
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;常用名词&lt;/h3&gt;

&lt;p&gt;XIC: input context&lt;br/&gt;
GC:  graphic context&lt;/p&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://fanqiang.chinaunix.net/a4/b8/20010601/190001312.html&quot;&gt;X Window 程式设计入门--第二章 X Programming 的第一步&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[编程之美]控制CPU使用率曲线</title>
   <link href="http://perthcharles.github.com/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/2013/04/25/os-profile-line"/>
   <updated>2013-04-25T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/2013/04/25/os-profile-line</id>
   <content type="html">&lt;h3&gt;闲聊&lt;/h3&gt;

&lt;p&gt;由于我的电脑被WIN7鄙视(跑WIN7显得比较慢)，同时如果按照原书中的代码需要掌握相当的WINDOWS API，对于这点目前我同样是做不到的。所以必须摸索一种LINUX下的方法完成类似的任务。&lt;br/&gt;
程序的思路应该不难理解，CPU使用率曲线是&lt;em&gt;刷新间隔内CPU的平均使用率&lt;/em&gt;。同时需要确认你的电脑CPU是几核的。比如我的电脑是双核的，则跑一个while(1)的话，CPU使用率只会达到50%。这点验证代码如下(shell)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cat 50-percent-cpu.sh
#!/bin/bash
while [ 1 ] 
do
:   
done
//注:shell空语句必须填上，在bash里冒号“:”表示空语句
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;linux下实现&lt;/h3&gt;

&lt;p&gt;我机器System Monitor更新CPU History的频率大概是1s(通过观察下方CPU1和CPU2使用率刷新频率得出)&lt;br/&gt;
如果将正弦曲线周期设置为40s，则至少需要制作40份不同的CPU使用频率出来。&lt;br/&gt;
对于特定值的CPU使用率，比如30%，则需要让CPU在1s内睡眠700ms, 执行while(1)300ms。至此具体的实现方法应该逐渐清晰了。&lt;br/&gt;
代码请见我github codeware仓库中的&lt;a href=&quot;https://github.com/PerthCharles/codeware/blob/master/sine-cpu.c&quot;&gt;sine-cpu.c&lt;/a&gt;。简单说明在用gcc编译的时候，由于用到了sin函数，所以需要加入-lm选项。即:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#gcc -lm sine-cpu.c -o sine-cpu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跑的时候使用taskset将程序设置到一个CPU上跑&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#taskset -c 0 ./sine-cpu
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;遇到问题&lt;/h3&gt;

&lt;p&gt;1.使用库函数请一定包含全部正确的头文件。&lt;br/&gt;
2.忙闲时间控制体现在:busy[i] = (double)(base_line + base_line&lt;em&gt;sin(w&lt;/em&gt;i))；&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>chrome bugs</title>
   <link href="http://perthcharles.github.com/2013/04/25/chrome-bugs"/>
   <updated>2013-04-25T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/04/25/chrome-bugs</id>
   <content type="html">&lt;h3&gt;chrome bug&lt;/h3&gt;

&lt;p&gt;不知到怎么回事，我本子(centos6.4)chrome每次打开后自动进入全屏模式，而且无法退出。尝试了一下方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#yum update google-chrome-stable.x86_64  //首先当然是想更新,结果无效
//然后yum remove后再yum install，依然无效
//最后找到可能原因是chrome配置出现了问题，所以先备份了先前的配置文件，然后重新让chrome生成一遍全新的配置文件
#cd /.config
#cp -r google-chrome google-chrome-bak 
#rm -rf google-chrome
//之后重新启动chrome，就像是chrome刚装上一样。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目前就是这样解决的无法退出全屏的问题，如果有更好的解决办法，请在博客下方留言，谢谢:)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>并行最小生成树算法</title>
   <link href="http://perthcharles.github.com/%E5%9B%BE%E8%AE%BA/2013/04/21/mst_parallel"/>
   <updated>2013-04-21T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/%E5%9B%BE%E8%AE%BA/2013/04/21/mst_parallel</id>
   <content type="html">&lt;h2&gt;论文&lt;/h2&gt;

&lt;p&gt;A distributed algorithm for minimum-weight spanning tree By:PG Gallager&lt;/p&gt;

&lt;h2&gt;重要定理&lt;/h2&gt;

&lt;p&gt;最小生成树重要定理：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;一个点的最小边一定是在最小生成树中的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用反正法能很快证明。&lt;/p&gt;

&lt;h2&gt;算法步骤&lt;/h2&gt;

&lt;p&gt;1.找到每个点对应的权值最小的边。&lt;br/&gt;
2.完成步骤1后，原图会被分割成若干个部分。每个部分用一个点代替，各个部分之间可能会存在多条边，仅保留权值最小的那条来表示相应两个部分的距离。&lt;br/&gt;
3.完成步骤2后，得到一个缩减后的图。重复前两个步骤直到缩减后的图只有一个节点。&lt;/p&gt;

&lt;h3&gt;图示&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/222.png&quot; alt=&quot;算法图示&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;MapReduce模型并行算法&lt;/h2&gt;

&lt;p&gt;要说明的一点是各个节点是否属于同一个部分，利用并查集实现。初始化时，每个节点对应一个集合，随着迭代次数的增加，集合的数量会快速减少。&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;Mapper
输入：(src, dest:weight)
输出：所有(src_setno, dest_setno:weight),其中src_setno != dest_setno
注解：src_setno表示src节点所在集合。对于输入进来的src_setno == dest_setno的边直接删除，因为这些边很显然是多余的。从而提高效率
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;Reducer
输入：(src_setno, dest_setno:weight)
输出：1.对于src_setno相同的输入，保留weight最小的那条边到最终的解集合中
      2.将保留边相应两个顶点所在集合进行合并
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3&gt;缺点&lt;/h3&gt;

&lt;p&gt;需要在每个节点维持并查集，而且reduce过程要对并查集进行写操作，这里可能成为性能瓶颈。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3&gt;进一步改进&lt;/h3&gt;

&lt;p&gt;在mapper与reducer之间添加combiner&lt;br/&gt;
因为两个集合之间可能有多条边，这样Mapper可能产生很多src_setno，dest_setno都相同的输出。通过combiner将这类型的输出进行合并，只保留weight最小的输入。减少Reducer需要处理的数据量&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;转载请注明出处&lt;br/&gt;
版权所有，侵犯必究&lt;/p&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>已知a[N],求b[i]=a[0]*a[1]..a[N]/a[i]</title>
   <link href="http://perthcharles.github.com/%E9%9D%A2%E8%AF%95%E9%A2%98/2013/04/20/problem-one"/>
   <updated>2013-04-20T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/%E9%9D%A2%E8%AF%95%E9%A2%98/2013/04/20/problem-one</id>
   <content type="html">&lt;h2&gt;问题描述&lt;/h2&gt;

&lt;p&gt;已知一个数组a[N]，构造一个数组b[N]，构造规则：b[i]=a[0]&lt;em&gt;a[1]&lt;/em&gt;a[2]...a[N]/a[i];&lt;br/&gt;
要求：1.不可以用除法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  2.时间复杂度为O(n)，空间复杂度为S(1)  
  3.除遍历使用的变量外，不可以使用其它变量  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;思路描述&lt;/h3&gt;

&lt;p&gt;线性时间内，构造：&lt;br/&gt;
b[i]=a[0]&lt;em&gt;a[2]...a[i]&lt;br/&gt;
a[i]=a[i]&lt;/em&gt;a[i+1]...a[N-1]&lt;br/&gt;
最后b[i]=b[i-1]*a[i+1]  (i=1,2,3...,N-3,N-2)&lt;br/&gt;
b[0]=a[1],b[N-1]=b[N-2].&lt;/p&gt;

&lt;h3&gt;源代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;void produce_b_by_a(int *a, int *b, int N)
{
    int i;
    b[0]=a[0];
    for(i = 1, i &amp;lt; N; i++){
        b[i] = b[i-1] * a[i];
    }
    for(i = N-2; i &amp;gt;= 0; i--){
        a[i] = a[i] * a[i+1];
    }
    for(i = 1; i &amp;lt; N-1; i++){
        b[i] = b[i-1] * a[i+1];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>mapreduce 学习笔记</title>
   <link href="http://perthcharles.github.com/2013/04/19/mapreduce-learning"/>
   <updated>2013-04-19T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/04/19/mapreduce-learning</id>
   <content type="html">&lt;h2&gt;工具&lt;/h2&gt;

&lt;p&gt;phoenix++:&lt;a href=&quot;http://mapreduce.stanford.edu/&quot;&gt;官网&lt;/a&gt;&lt;br/&gt;
下载源代码后在doc目录下能找到相关的论文。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;优点：对于单机多核的机器，只要支持P-THREAD库基本就能跑这个工具。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;应用场合&lt;/h2&gt;

&lt;p&gt;MapReduce编程模型对数据密集型的问题效果比较显著。&lt;/p&gt;

&lt;h2&gt;数据集搜寻&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;webgraph.dsi.unimi.it&quot;&gt;WebGraph&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;学习资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://blademaster.ixiezi.com/2010/03/27/google-mapreduce%E4%B8%AD%E6%96%87%E7%89%88/&quot;&gt;Google MapReduce中文版&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://blog.csdn.net/inte_sleeper/article/details/7217787&quot;&gt;基于map-reduce的并行最短路径算法&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;blog.csdn.net/v_july_v/article/details/6637014&quot;&gt;MapReduce技术的初步了解与学习&lt;/a&gt;
下面这篇有空再看看，且里面代码的显示方案很不错&lt;br/&gt;
&lt;a href=&quot;http://yangguan.org/mapreduce-patterns-algorithms-and-use-cases/&quot;&gt;MapReduce的模式、算法和用例&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;过程中发现的优秀博客&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;famousphil.com/blog&quot;&gt;famousphil.com&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;highlyscalable.wordpress.com&quot;&gt;Highly Scalable Blog&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;blog.csdn.net/nuaaqy&quot;&gt;nuaaqy专栏：研究Hadoop-MapReduce中&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;我做的PPT&lt;/h2&gt;

&lt;p&gt;介绍最短路径和最小生成树在MAPREDUCE编程模型下的并行算法&lt;br/&gt;
&lt;a href=&quot;http://vdisk.weibo.com/s/yryCD&quot;&gt;MST+Dijkstra+MapReduce&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Trace驱动的memory模拟：综述</title>
   <link href="http://perthcharles.github.com/papars/2013/04/13/trace-driven-survey"/>
   <updated>2013-04-13T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/papars/2013/04/13/trace-driven-survey</id>
   <content type="html">&lt;h1&gt;论文来源&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;(在google scholar中搜索：trace-driven memory simulation a survey )
#wget http://www.cs.amherst.edu/~sfkaplan/courses/spring-2004/cs40/papers/UM:TDMS.pdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;博客里面写的只是粗略的理解，错误难免。想更准确的了解还是请看论文原文。&lt;/p&gt;

&lt;h1&gt;简介&lt;/h1&gt;

&lt;p&gt;处理器速度与memory速度之间的差距越来越大，成“剪刀口”型增长趋势。在memory-system设计被硬件实现之前，找到评价memory-system设计的方法显得十分重要。&lt;br/&gt;
其中一种有效的方法就是：通过抓取真实应用的访存trace，然后通过在模拟器上模拟抓取下来的trace行为达到测试memory-system的性能效果。下面将根据前面提到的论文，适当整理思路，以便之后学习。&lt;br/&gt;
所谓访存trace，就是一系列的对内存进行访问的操作序列（a sequence of memory references）&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;主要难点&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1，收集完整的trace信息很难。特别是对于多进程，操作系统，动态链接或动态编译产生的访存trace很难获取。
2，访存trace一般很大。一般都是10G～100G这个量级的。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Trace driven memory simulation主要流程&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1，trace collect：    收集某些选定负载的访存序列。
2，trace reduction:    由于trace文件一般都很大，如果模拟完成的trace将会十分耗时。通过去除不需要、冗余或是不感兴趣的数据来提高整体的效率。
3，trace processing:   将得到的trace文件当初输入给模拟器处理
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;对各类方法的评价标准&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;准确性：    模拟出来的性能与真实性能之间的差距；reduction之后的trace模拟结果与完成trace模拟结果之间的差异等
速度：       每秒收集到的trace entry个数（无法跨平台对比）；entry收集速度/entry产生速度;entry processing速度/entry产生速度；总模拟时间/正常执行时间
额外的内存开销
reduction 比例
portability,flexibility,expense,easy-of-use
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Trace collect&lt;/h3&gt;

&lt;p&gt;评价trace质量的标准主要就是：完整性和详细性。另外在收集过程中，不得收录额外引起的访存动作，主要就是收集工作本身产生的访存动作不应该被收录到trace中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;完整性：所有的访存动作都要收集，包括所有用户级进程和操作系统内核产生的访存动作。
详细性：是否给trace添加一些额外的信息，比如VM page-table状态，访存动作类型（读，写，执行），大小（字，半字，字节等）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般的工具在收集的时候如果trace buffer写满了，都需要停下来将buffer里面的数据导出到外部。&lt;br/&gt;
各种工具收集方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trace收集方式的不同主要体现在收集动作对应系统层次的不同
------------软件层次-------------
|   操作系统级的单步执行  |
|   编译器           |
|   汇编器           |
|   连接器和加载器       |
|--------------------------------
|   微指令           |
|--------------------------------
|   物理层：探测物理信号  |
---------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Trace reduction&lt;/h3&gt;

&lt;p&gt;各类方法的主要不同在于reduction比例的不同和reduction方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;主要reduction方式：
压缩：       利用标准的数据压缩算法对数据进行压缩（觉得这种方法不实用）
重要事件： 在收集trace的时候只收集满足一定条件的trace，详见论文
过滤：       由于每个研究人员的研究兴趣重点不同，想要模拟的trace类型也就不同
抽样：       分时间抽样和集合抽样。（这种方法使用组内开发的工具：HMTT实践过）
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Trace processing&lt;/h3&gt;

&lt;p&gt;因为memory-system设计的多样性（页面替换算法、cache大小、写策略：写穿透等，line大小），所以在将trace输入到模拟器时，自然就想一遍输入，就能跑几种不同的配置方式。为了达到这个目的就导致来trace processing方式的多样性。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;转载请注明出处。&lt;br/&gt;
版权所有，侵犯必究&lt;/p&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>linux 命令学习（五）</title>
   <link href="http://perthcharles.github.com/2013/04/12/linux-using"/>
   <updated>2013-04-12T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/04/12/linux-using</id>
   <content type="html">&lt;h2&gt;/etc/motd使用&lt;/h2&gt;

&lt;p&gt;如果你正在使用一台服务器，并且想通知每一个新登录这台服务器的用户一个消息。&lt;br/&gt;
比如你需要在服务器上进行一些测试工作，肯定希望其他登录进来的用户不要跑别的程序。这时你可以在/etc/motd文件中编辑你的通知消息，每一个新登录的用户都会看到这个消息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cat /etc/motd
Hello everyone,
This server will be used to run some test-programs at 2013/04/12 0:00 ~ 24:00
Please do not login server at this time. ^_^
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;找出含特定字符串的所有文件&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#grep -ir (string-to-find) (search-files)
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>X window</title>
   <link href="http://perthcharles.github.com/2013/03/28/x-window"/>
   <updated>2013-03-28T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/28/x-window</id>
   <content type="html">&lt;h2&gt;Type of XEvent&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Keyboard events                | KeyPress, KeyRelease
Pointer events                 | ButtonPress, ButtonRelease, MotionNotify
Window crossing events         | EnterNotify, LeaveNotify
Input focus events             | FocusIn, FocusOut
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考资料：(X Window学习xlib---X Event)[http://blog.csdn.net/unailbobo/article/details/3036618]&lt;/p&gt;

&lt;h3&gt;问题&lt;/h3&gt;

&lt;p&gt;如果仅仅是调整x window的位置，是不是没有数据发送出去？！  ----添加DEBUG，只是调整位置，看是否有数据包发送&lt;/p&gt;

&lt;p&gt;怎么给X window发送event?？？？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;关键点：xwin_process_events函数调用XNextEvent来从g_display中获取event事件，所以问题变为如何在g_display中加入我们想要的事件？？？
    这种方式现在还没思路，改用直接调用rdp_send_input()函数来处理
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在需要保证前后发送的两个数据包依赖性要保证好，比如第一个操作是打开word，那么第二个操作必须等服务器那边发送回响应后才发送过去&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;关键问题：怎么设置响应时间？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果单纯的从rdp_send_input发送数据（比如移动鼠标），那么返回数据后，客户端是否能显示正常？这点要验证！&lt;/p&gt;

&lt;p&gt;Standard KeySym names are obtained from &amp;lt;X11/keysymdef.h&gt; by removing the XK_ prefix from each name.&lt;/p&gt;

&lt;h5&gt;coding log&lt;/h5&gt;

&lt;p&gt;bool RECORD is define in rdesktop.c  line:460&lt;/p&gt;

&lt;p&gt;因为想读取的是二进制文件，所以要规定一个文件格式&lt;/p&gt;

&lt;p&gt;xwin.c:2283: warning: format ‘%u’ expects type ‘unsigned int’, but argument 2 has type ‘time_t’
xwin.c: In function ‘xwin_process_events’:
xwin.c:2379: warning: format ‘%x’ expects type ‘unsigned int’, but argument 2 has type ‘KeySym’
xwin.c:2382: warning: format ‘%x’ expects type ‘unsigned int’, but argument 2 has type ‘KeySym’&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%x,  (unsigned int) keysym
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;xwin.c:2432: warning: format ‘%u’ expects type ‘unsigned int’, but argument 2 has type ‘time_t’&lt;/p&gt;

&lt;h3&gt;注意事项&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;自己定义的：FILE * record 需要用完后关闭
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;问题&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;直接设置timeout判断上一个动作是否完成不行，因为在上一个动作还在进行的时候，也有可能中途图像不变，这样虽然会timeout，但是上一个动作其实并没有完成！
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>linux 反汇编初步</title>
   <link href="http://perthcharles.github.com/2013/03/25/linux-disassemble"/>
   <updated>2013-03-25T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/25/linux-disassemble</id>
   <content type="html">&lt;h2&gt;工具&lt;/h2&gt;

&lt;p&gt;十六进制编辑器：hexedit&lt;br/&gt;
objdump:&lt;/p&gt;

&lt;hr /&gt;

&lt;h3&gt;hexedit使用&lt;/h3&gt;

&lt;p&gt;暂时只用hexedit来读二进制文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#hexedit filename  //查看文件  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作键&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   Ctrl-X: save and exit  
   Ctrl-C: exit without saving  
   tab: 在hex和ascii窗口之间切换  
   Ctrl-U: undo all  
   Ctrl-S: search forward  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;objdump使用&lt;/h3&gt;

&lt;p&gt;编译程序的时候，gcc添加-g选项，增加调试信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#gcc test.c -g -o test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-S(source):表示读取哪个文件
-j:选择读出哪个section，可以通过objdump -h来查看所有的section
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h3&gt;看懂AT&amp;amp;T汇编&lt;/h3&gt;

&lt;p&gt;由于objdump反汇编得到的结果主要都是AT&amp;amp;T格式的汇编(不过好像可以选择？)，而且linux内核代码也有不少AT&amp;amp;T格式的汇编代码，所以有必要学习一下&lt;/p&gt;

&lt;h4&gt;AT&amp;amp;T汇编特点&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;1.寄存器前面要加%，如：mov %eab,%ebx
    注意源寄存器和目标寄存器的顺序与intel汇编更好相反，at&amp;amp;t中左边是源寄存器，右边是目标寄存器。所以上面指令是将eax的值赋给ebx
2.立即数/常数前面要加‘$’,符号常数值直接用。
    关于符号常量注意理解下面两句：
    mov A,%eax  //将A代表的值赋给eax,如A=10，则eax里面的值就是10
    mov $A,%eax     //将A代表的值当作地址，将对应地址的值赋给eax，如A=0x10,0x10处存则20，则把地址0x10处对应的值20赋给eax
3.movb:8位(byte)   movw：16位(word)  movl：32位(long)  
others: s=short(16-bit integer) or single(32-bit floating point)
    q=quad(64 bits)
    t=ten bytes(80 bits floating point)
注：如果suffix没有指定且不是内存操作，GAS(Gnu AS)会根据目标寄存器的大小来决定
4.call/jmp语句的操作数前面要加上“*”作为前缀，远跳转ljmp,远调用lcall，远返回lret

5.寻址规则：displacement(base register, offset register, scalar multiplier)
  计算方法：(base+dis)+(offset*multiplier)
  举例：
    movl    -4(%ebp, %edx, 4), %eax  # Full example: load *(ebp - 4 + (edx * 4)) into eax
    movl    (%ecx), %edx             # No offset: copy the target of a pointer into a register
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;C语言内嵌汇编&lt;/h4&gt;

&lt;p&gt;格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_asm_(&quot;asm statement&quot;:outputs:inputs:registers-modified)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tips:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.在嵌入汇编中，寄存器前面要加两个%，因为gcc在编译时，会去掉一个%再输出成汇编格式
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;主要寄存器及其作用&lt;/h4&gt;

&lt;h5&gt;8086有14个16位寄存器，按照用途分为：&lt;/h5&gt;

&lt;p&gt;1.通用寄存器(8个)&lt;br/&gt;
2.指令指针(IP,1个)&lt;br/&gt;
3.标志寄存器(FR，1个)&lt;br/&gt;
4.段寄存器(4个)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;通用寄存器&lt;/em&gt;又可以分成2类：数据寄存器和指针寄存器及变址寄存器，各4个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ax:常用于计算。另外所有的I/O指令都使用这一寄存器与外界设备传送数据
bx:基址寄存器  
cx:计数寄存器  
dx:数据寄存器  

SP:堆栈指针，与SS配合使用，可指向目前的堆栈位置  
BP:基址寄存器，可作为SS的相对基址位置  
SI:source index,源变址寄存器------暂不理解  
DI：destination index,目的变址寄存器  
上面四个寄存器只能按16位进行操作，主要用来形成操作数的地址  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;指令指针IP&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IP:16位专用寄存器，用来指向当前执行指令的下一条指令的地址。注意，IP指向的是指令地址的段内地址偏移量  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;标志寄存器FR&lt;/em&gt;&lt;br/&gt;
16位的寄存器，有意义的有9位，6位是状态位，3位是控制位&lt;br/&gt;
分布图：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#################################################
#  #  #  #  #OF#DF#IF#TF#SF#ZF#  #AF#  #PF#  #CF#
#################################################
#15#14#13#12#11#10# 9# 8# 7# 6# 5# 4# 3# 2# 1# 0#
#################################################
各个标志的含义：  
OF:overflow  
DF:direction
IF:中断允许标志，标志是否响应CPU‘外部可屏蔽‘中断，1表示响应
TF:跟踪标志
SF:符号标志，与运算结果的最高位相同
ZF:零标志，反映运算结果是否为0
AF:辅助进位标志
PF:奇偶标志反映运算结果中’1‘的个数，PF=1表示偶数个’1‘
CF:进位标志反映运算结果是否产生进位或借位
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;段寄存器&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CS:code segment
DS:data segment
SS:stack segment
ES:extra segment
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4&gt;80386寄存器&lt;/h4&gt;

&lt;p&gt;寄存器都是32位宽&lt;br/&gt;
&lt;em&gt;通用寄存器&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EAX，EBX，ECX，EDX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;特殊寄存器&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ESI：通常在内存操作中作为“源地址指针”使用，DS是默认段寄存器
EDI：通常在内存操作中作为“目标地址指针”，DS是默认段寄存器
EBP：通常被高级语言编译器用以建造‘堆栈帧’来保存函数或过程的局部变量，SS是默认段寄存器
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3&gt;主要参考资料&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cppblog.com/tdweng/articles/120852.html&quot;&gt;汇编中各寄存器的作用-堂吉歌德&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax&quot;&gt;X86 Assembly/GAS Syntax&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>Gnu AS 汇编实践</title>
   <link href="http://perthcharles.github.com/2013/03/25/gnu-as-pratice"/>
   <updated>2013-03-25T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/25/gnu-as-pratice</id>
   <content type="html">&lt;h3&gt;首先尝试一个最近简单的Hello world程序&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(void) 
{
        printf(&quot;Hello, world!\n&quot;);
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存文件：hello.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#gcc hello.c -o hello
#./hello
Hello World!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;产生等价的32位X86 汇编语言程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#gcc -S -m64 hello.c  //将m32改位m64，因为我的机器是64的
#ls hello*
hello  hello.c  hello.s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到产生来与hello.c等价的汇编语言程序hello.s,下面用gcc编译这个汇编程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#gcc -m64 hello.s -o hello-asm
#./hello-asm
Hello World!
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>ssh免密码登录</title>
   <link href="http://perthcharles.github.com/2013/03/24/ssh-free-pwd"/>
   <updated>2013-03-24T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/24/ssh-free-pwd</id>
   <content type="html">&lt;h3&gt;博客背景&lt;/h3&gt;

&lt;p&gt;有时候在两台服务器上面工作，需要同时操作它们，如果在两个窗口里面反复切换就显得很麻烦。所以先配置ssh免密码登录，然后用其他工具&lt;/p&gt;

&lt;p&gt;假设A是本地主机，B是远程主机。想要从A远程访问B的时候免密码登录&lt;br/&gt;
首先在A上生成公钥和私钥，然后在B机器上记录在公钥&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#(A)ssh-keygen -t rsa //连续三次回车，这里选择不设置密码  
#(A)ssh root@ip-of-B  //这次还需要密码  
#(B)ls -a  //查看是否存在.ssh文件夹  
#(B)mkdir .ssh &amp;amp;&amp;amp; chmod 0700.ssh &amp;amp;&amp;amp; exit   
#(A)scp ~/.ssh/id_rsa.pub root@ip-of-B:.ssh/id_rsa.pub //还需要输入密码  
#(B)touch /root/.ssh/authorized_keys  //生成一个空文件，如果文件已经存在，则跳过这条命令  
#chmod 600 ~/.ssh/authorized_keys  //设置该文件只有root能查看，因为这个文件是用于保存ssh客户端生成的公钥的，该文件是在ssh服务端配置文件/etc/sshd_config中指定的  
#cat /root/.ssh/id_rsa.pub &amp;gt;&amp;gt; /root/.ssh/authorized_keys  //将A传过来的公钥写入authorized_keys文件，注意这里必须使用 &quot;&amp;gt;&amp;gt;&quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此配置完成了，现在在A上面使用ssh登录B应该就不用输入密码了。&lt;/p&gt;

&lt;h3&gt;其他说明&lt;/h3&gt;

&lt;p&gt;如果在A上面需要在脚本里面执行B机器上面的命令，除来使用实验室提供的工具外，可以简单的使用下面的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ssh root@ip-of-B:/pwd &quot;command1;command list&quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然这里只是一个简单的例子，所以生成的密钥没有设置密码。如果是短期使用可以先这样配置使用，然后再将密码从B机器上面的authorized_keys里面删除，下次你再需要用的时候再将其加进去。这样安全性要好些，如果长期使用还是建议不要使用没有密码的密钥，特别是共用服务器。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>一道C语言二进制反码题</title>
   <link href="http://perthcharles.github.com/%E9%9D%A2%E8%AF%95%E9%A2%98/2013/03/24/negation-in-c"/>
   <updated>2013-03-24T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/%E9%9D%A2%E8%AF%95%E9%A2%98/2013/03/24/negation-in-c</id>
   <content type="html">&lt;h3&gt;题目&lt;/h3&gt;

&lt;p&gt;请写出下面程序在32/64位机器上的输出结果&lt;br/&gt;
编译器：GCC&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;sdtio.h&amp;gt;  

int main(void)
{
    unsigned char a = 0xa5;
    printf(&quot;%d\n&quot;,~a);
    char b = ~a;
    printf(&quot;%d\n&quot;,b);
    unsigned char c = ~a;
    printf(&quot;%d\n&quot;,c);

    return 0;
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;解答:&lt;/h3&gt;

&lt;p&gt;char型数据占一个字节，故&lt;br/&gt;
(a)0xa5 = 1010 0101 = 165&lt;br/&gt;
但是~a并不是a直观的取反，在32位或int长度为4的64位系统中，char和unsigned char 都是按照32位（4字节）取反的，所以这样一来&lt;br/&gt;
(~a) = ~(0x000000a5) = 0xffffff5a//这点可以按照%x格式打印~a验证&lt;br/&gt;
按照%d输出的话，最高位会当成符号位&lt;br/&gt;
所以0xffffff5a先取反得到(符号位除外)&lt;br/&gt;
0x000000a5,然后+1得到//补码与原码的相互转化规则：除符号位外取反再+1&lt;br/&gt;
0x000000a6 = 166&lt;br/&gt;
符号为负，所以第一条打印信息为-166&lt;/p&gt;

&lt;p&gt;解释完第一条打印信息，后两个就好解释了，因为先将~a存入到了char或unsigned char型中，~a取反后的高位被抛弃，所以直接得到0x5a，即90&lt;/p&gt;

&lt;h3&gt;更进一步&lt;/h3&gt;

&lt;p&gt;将下面代码反汇编，查看取反操作是否是上面的说法：按照32位取反&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
int main(void)
{
    unsigned char a = 0xa5;
    printf(&quot;%d\n&quot;,~a);

    return 0;
}

#gcc test.c -o -g test 
#objdump -S test &amp;gt; test.debug
#cat test.debug
...
00000000004004c4 &amp;lt;main&amp;gt;:
#include&amp;lt;stdio.h&amp;gt;
int main(void)
{
  4004c4:   55                      push   %rbp
  4004c5:   48 89 e5                mov    %rsp,%rbp
  4004c8:   48 83 ec 10             sub    $0x10,%rsp
    unsigned char a = 0xa5;
  4004cc:   c6 45 ff a5             movb   $0xa5,-0x1(%rbp)
    printf(&quot;%d\n&quot;,~a);
  4004d0:   0f b6 45 ff             movzbl -0x1(%rbp),%eax
  4004d4:   89 c2                   mov    %eax,%edx
  4004d6:   f7 d2                   not    %edx
  4004d8:   b8 f8 05 40 00          mov    $0x4005f8,%eax
  4004dd:   89 d6                   mov    %edx,%esi
  4004df:   48 89 c7                mov    %rax,%rdi
  4004e2:   b8 00 00 00 00          mov    $0x0,%eax
  4004e7:   e8 cc fe ff ff          callq  4003b8 &amp;lt;printf@plt&amp;gt;

    return 0;
  4004ec:   b8 00 00 00 00          mov    $0x0,%eax
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到指令&quot;not %edx&quot;是直接按照32位进行取反的&lt;br/&gt;
如果对程序进行-O2优化编译的话，就看得更直观&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#gcc -O2 test.c -g -o test-O2
#objdump -S test-O2 &amp;gt;test-O2.debug
#cat test-O2.debug
...
00000000004004d0 &amp;lt;main&amp;gt;:
#include&amp;lt;stdio.h&amp;gt;
int main(void)
{
  4004d0:       48 83 ec 08             sub    $0x8,%rsp
     unsigned char a = 0xa5;
     printf(&quot;%d\n&quot;,~a);
  4004d4:       be 5a ff ff ff          mov    $0xffffff5a,%esi
  4004d9:       bf e8 05 40 00          mov    $0x4005e8,%edi
  4004de:       31 c0                   xor    %eax,%eax
  4004e0:       e8 d3 fe ff ff          callq  4003b8 &amp;lt;printf@plt&amp;gt;

     return 0;
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到程序直接将0xffffff5a赋给esi寄存器了&lt;/p&gt;

&lt;h3&gt;我本子相关信息&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#uname -r
2.6.32-358.el6.x86_64
#gcc -v
gcc version 4.4.7 20120313 (Red Hat 4.4.7-3) (GCC)
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>硬盘安装linux</title>
   <link href="http://perthcharles.github.com/2013/03/24/install-linux-from-disk"/>
   <updated>2013-03-24T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/24/install-linux-from-disk</id>
   <content type="html">&lt;h3&gt;介绍&lt;/h3&gt;

&lt;p&gt;目前正在用的系统是WIN7系统，由于现在系统性能表现越来越差，而自己又不想重新安装这个系统，所以就选择在电脑上面安装双系统。&lt;br/&gt;
再者最近在学习linux，所以就干脆选择安一个linux来玩玩，目前选择的是CentOS6.4。至于为什么选择这个版本，大家都知道的：稳定！当然这样一来桌面软件支持就略显不足，不过暂时够用就好。&lt;/p&gt;

&lt;h3&gt;用到的软件&lt;/h3&gt;

&lt;p&gt;EasyBCD:这款软件用来帮助你在WIN7系统下面制作启动项。这里只简单说明我用的步骤，更具体的使用方法请&lt;a href=&quot;www.google.com&quot;&gt;google之&lt;/a&gt;&lt;br/&gt;
wingrub:利用这个软件，可以帮助你在制作EasyBCD启动项的时候确定你需要选用的分区号。&lt;br/&gt;
Acronis Disk Director Suite:帮助你在WIN7下无损分区，目前用户体验良好。不过保险起见，最好还是先备份重要文件啦。&lt;/p&gt;

&lt;h3&gt;安装步骤&lt;/h3&gt;

&lt;p&gt;话不多说，这就开工&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;打开EasyBCD-&amp;gt;  
Add New Entry-&amp;gt;  //这一步就是给你liunx镜像文件制作启动项，或许在linux下更准确的说法是修改grub？  
选择NeoGrub标签页-&amp;gt;  
点击Install,点击Configure,进行配置，其实我感觉这个是标准的grub的写法。最重要的是各个操作系统的配置文件对应镜像需要解压出来的文件有区别，这点很重要。很多人的博客并没有明显的区分或是主要针对Ubuntu这个系统进行讲解的    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最重要的就是配置了，这个地方网上有不少人进行了解释，但是我觉得我觉得最简单最实用的还是百度空间的&lt;a href=&quot;http://hi.baidu.com/sf_chipan&quot;&gt;小治的空间&lt;/a&gt;,在此感谢作者！&lt;/p&gt;

&lt;h3&gt;各个系统的配置文件写法和镜像需要解压缩的文件&lt;/h3&gt;

&lt;h4&gt;CentOS系列&lt;/h4&gt;

&lt;p&gt;文件目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CentOS-xx-i386/x86_64-bin-DVD1/2.iso  
initrd.img  //initrd.img和vmlinuz这两个文件在ioslinux文件夹下  
vmlinuz  
images/  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;title install centos XXX  
kernel (hd0,6)/vmlinuz  //hd0 表示你的镜像文件放在你电脑对应的那块硬盘；6表示镜像存放分区的编号。  
initrd (hd0,6)/initrd.img  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;其他系列&lt;/h4&gt;

&lt;p&gt;其他发行版本目前还没有尝试，有需求的话，可以去参考百度空间的&lt;a href=&quot;http://hi.baidu.com/sf_chipan&quot;&gt;小治的空间&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;几点注意事项&lt;/h4&gt;

&lt;hr /&gt;

&lt;p&gt;配置文件中对应的分区编号可以用wingrub帮忙确定的^_^&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;镜像文件最好放在linux能够识别的文件系统中，由于FAT32单个文件最大不能超过4G，对于CentOS-DVD安装可能就不能可行了。大家可以尝试放到ext系列的文件系统下(推荐ext3)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;再多说一句，如果你想在WIN7环境下识别ext3文件系统的分区的话，可以安装Ext2Fsd这个软件。&lt;/p&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>在centos系统下，挂在ntfs格式的磁盘分区</title>
   <link href="http://perthcharles.github.com/centos6.4/2013/03/24/centos-mount-ntfs"/>
   <updated>2013-03-24T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/centos6.4/2013/03/24/centos-mount-ntfs</id>
   <content type="html">&lt;h3&gt;前提介绍&lt;/h3&gt;

&lt;p&gt;在我在WIN7系统下硬盘安装好双系统后，有不少时候需要访问一些WIN7系统下的文件，如果反复的重启电脑的话那就太烦人了。而Centos又不能直接挂载ntfs格式的磁盘分区，网上搜来一圈找到一个可行的方法&lt;/p&gt;

&lt;h3&gt;需要的软件&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;fuse&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#rpm -qa |grep fuse //查看系统是否已经安装软件  
#yum list |grep fuse  
#yum install fuse  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你的源里面没有这个软件，那就去添加更好的源吧，不会添加源的可以参照我另一片博客：&lt;a href=&quot;http://perthcharles.github.com/centos6.4/2013/03/18/yum-using&quot;&gt;yum使用指南&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ntfs-3g&lt;/em&gt;&lt;br/&gt;
这个软件我选择的从源码安装，当然你也可以选择从yum源安装&lt;br/&gt;
&lt;a href=&quot;http://www.tuxera.com/community/ntfs-3g-download/&quot;&gt;ntfs-3g下载地址:www.tuxera.com/community/ntfs-3g-download/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;挂在分区&lt;/h3&gt;

&lt;p&gt;在安装好上面这两个软件后，应该就可以挂在ntfs磁盘分区了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#fdisk -l //查看硬盘所有分区  
#mount -t ntfs-3g /dev/xxx /mnt/xxx  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想开机就挂在上的话，我的方法是修改/etc/profile，再最后加上上面的mount命令&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>vim 编码相关问题</title>
   <link href="http://perthcharles.github.com/2013/03/23/vim-decode"/>
   <updated>2013-03-23T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/23/vim-decode</id>
   <content type="html">&lt;h3&gt;vim中文乱码问题--本机设置&lt;/h3&gt;

&lt;p&gt;首先应该选用utf8格式的编码比较靠谱，同时为了防止乱码现象，应该保障系统设置和vim的设置相一致&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#echo $LANG //查看系统当前选用编码方式  
#LANG=zh_CN.utf8  
#vim /etc/vimrc  //将set fileencodings 设置如下  
set fileencodings=utf8,gbk,big5,ucs-bom,latin1  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;其他推荐的设置&lt;/h3&gt;

&lt;p&gt;中文环境GBK码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#LANG=zn_CN.gbk  
#vim /etc/vimrc  
set fileencodings=gbk,big5,ucs-bom,latin1  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中文环境UTF8参照之前的本机设置&lt;br/&gt;
英文环境就直接用就好了，所以推荐装机的时候就选择英文系统，毕竟码代码还是英文用的多点&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>utorrent+mplayer使用</title>
   <link href="http://perthcharles.github.com/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/2013/03/23/utorrentmplayer"/>
   <updated>2013-03-23T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/2013/03/23/utorrentmplayer</id>
   <content type="html">&lt;h3&gt;utorrent&lt;/h3&gt;

&lt;p&gt;为了在centos上面下载六维空间的资源，就必须选择一个给力的下载器，但是目前utorrent客户端只有WINDOWS版本，所以就必须曲线救国了。我的方法如下：&lt;br/&gt;
首先确保你添加了第三方的源，如果不会添加请移步&lt;a href=&quot;http://perthcharles.github.com/centos6.4/2013/03/18/yum-using/&quot;&gt;yum 源的使用&lt;/a&gt;&lt;br/&gt;
然后安装在linux环境下安装windows软件的平台，想了解更多的请&lt;a href=&quot;www.google.com&quot;&gt;google wine&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#yum installl wine  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装好wine环境后，只要下载一个windows环境下的utorrent.exe文件，就可以直接打开这个软件下载六维的软件了。开始享受吧！&lt;/p&gt;

&lt;h3&gt;mplayer使用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#yum list|grep mplayer  //查看你的源中是否有mplayer  
#mplayer [-fs] filename  //-fs是可选项，表示全屏播放  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要说明的是我的mplayer没有安装图形界面(自己懒的动)，所以只能选择在命令行下输入命令播放视频，不过够用就行。&lt;/p&gt;

&lt;h4&gt;无线网卡配置&lt;/h4&gt;

&lt;p&gt;目前笔记本的无线网络功能处于无效状态。同时目前还没有需求，所以就没有配置。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Bench 安装记录</title>
   <link href="http://perthcharles.github.com/benchmarks/2013/03/23/hp-bench"/>
   <updated>2013-03-23T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/benchmarks/2013/03/23/hp-bench</id>
   <content type="html">&lt;h3&gt;操作系统信息&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#uname -r  
2.6.32-220.el6.x86_64  
#cat /etc/issue  
CentOS release 6.2 (Final)  
#gcc -v  
Using built-in specs.  
Target: x86_64-redhat-linux  
Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-languages=c,c++,objc,obj-c++,java,fortran,ada --enable-java-awt=gtk --disable-dssi --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-1.5.0.0/jre --enable-libgcj-multifile --enable-java-maintainer-mode --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --disable-libjava-multilib --with-ppl --with-cloog --with-tune=generic --with-arch_32=i686 --build=x86_64-redhat-linux  
Thread model: posix  
gcc version 4.4.6 20110731 (Red Hat 4.4.6-3) (GCC)  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;MonetDB+tpc-h&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#tar -xjvf MonetDB-11.5.9.tar.bz2  
#`pwd`/configure --enable-monetdb5 --enable-sql --enable-optimize --with-java=/usr/lib/jvm/java-1.6.0  
//configure: error: OpenSSL library not found but required for MonetDB5  
#yum install openssl-devel  
//configure: error: PCRE library not found but required for MonetDB5  
#yum install pcre-devel pcre  
//configure: error: libxml2 library not found but required for MonetDB5  
#yum install libxml2-devel  
#make &amp;amp;&amp;amp; make install  

#monetdbd create MonetDB-data  
#monetdbd start MonetDB-data  
#monetdb create SF4  
#monetdb start SF4  
#monetdb release SF4  

#cd ./sql/benchmarks/tpch/dbgen  
#cp makefile.suite makefile  
#make  
#./dbgen -s 4 //produce 4G data for test  
#cd ..  
#vim load.sh  //change the following stuff  
SQL='mclient -l sql -d SF4'  
SF='dbgen'  
#vim run.all  //change the following stuff  
SQL=&quot;mclient -l sql -d SF4&quot;  
#vim .monetdb //add the defult user and password  
user=monetdb  
password=monetdb  
#cp -r dbgen DBGEN  //rename the folder for load.sh  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;voltdb+tpc-c&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#unzip voltdb-master.zip //get this file from github  
//add the EPEL yum source  
//and make sure the ant's version is 1.7 or later  
#ant dist  
#cd tests/test_apps/tpcc  
#./run.sh  //run the server  
#./run.sh client //run the client  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;memcached+britus&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//install libevent，download the file then  
#./configure --prefix=/usr &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install  
//install php and extensions  
#yum install php php-pecl-memcached php-pear-noarch  
//install memcached  
#./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install  
//start the memcached  
#/usr/local/bin/memcached -d -m 1024 -u root -l [your ip address] -p 12000 -c 1024 -P memcached.pid  
//if you want to stop memcached  
#kill `cat memcached.pid`  
//restart the apache  
#service httpd restart  
#./brutis -t tests/append.xml -x [your ip address]:12000 -o append -v  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;more tips&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//solution for PHP Fatal error: Call to undefined function posix_getppid()  
#install php-process  
//solution for function XXX is deprecated,in php  
#add a '@' before the deprecated function  
//solution for XML. Class DOMDocument missing  
#yum install php-xml.x86_64  
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>yum使用指南</title>
   <link href="http://perthcharles.github.com/centos6.4/2013/03/18/yum-using"/>
   <updated>2013-03-18T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/centos6.4/2013/03/18/yum-using</id>
   <content type="html">&lt;h3&gt;yum安装软件&lt;/h3&gt;

&lt;p&gt;当你想安装软件的时候，可能你只知道一个大概的名字或者你想确认你系统的yum源中是否存在该软件包，那么你就可以用下面的命令来查找确认&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #yum list |grep softname  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想知道你现在已经安装来哪些包，可以使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#rpm -qa | grep softname  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到软件对应的正确软件包名称之后，就可以使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#yum install softname  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来正确安装你需要的软件了&lt;/p&gt;

&lt;h4&gt;如果提示有依赖文件没找到（通常是库文件）,那么可以尝试使用&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#yum provides */miss-file-name*  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来看看哪些安装程序可能提供这样的库文件&lt;/p&gt;

&lt;h3&gt;添加源&lt;/h3&gt;

&lt;p&gt;如果你需要安装的软件在现有的源里没有，你就可以尝试添加一个新的源到你的系统里面。当然，你必须保证添加的源跟你的系统是一致的（比如都是64位，对应centos-6）&lt;br/&gt;
//更改系统yum源配置,以添加google源为例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#vim /etc/yum.repos.d/google.repo  
[google]  
name=Google - i386  
baseurl=https://dl.google.com/linux/rpm/stable/i386  
enabled=1  
gpgchech=1  
pgpkey=https://dl-ssl.google.com/linux/linux_signing_key.pub  
//之后你就可以在源里面找到之前你可能找不到的安装包，比如chrome  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要说明的是，上面google的源是对应32位系统的，如果你是64位系统你需要将stable后面改为x86_64.并且上面google的链接直接用浏览器应该是打不开的，也就是说你没法从浏览器里面看到这个源里面都有哪些安装包&lt;/p&gt;

&lt;p&gt;如果碰到提示需要GPG-KEY的时候，可以先上网找到对应的KEY的链接，然后输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#rpm --import url-to-the-key-you-needed  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在添加完多个源后，可以再装一个yum的插件让它自动选择最开的源进行下载安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#yum install yum-fastestmirror -y //-y 表示需要你确认的时候，默认选择yes 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于国内的用户来说，&lt;a href=&quot;http://mirrors.ustc.edu.cn&quot;&gt;中科大的源&lt;/a&gt;是不错的选择,&lt;a href=&quot;lug.ustc.edu.cn/wiki/mirrors/help/debian&quot;&gt;这里&lt;/a&gt;是相关的使用帮助。&lt;/p&gt;

&lt;h3&gt;安装单独的软件包&lt;/h3&gt;

&lt;p&gt;如果你不能按照安装chrome那样直接找到正确的源的话，可以尝试到提供rpm包索引的网站去查找相应的软件&lt;br/&gt;
推荐使用：&lt;a href=&quot;rpm.pbone.net&quot;&gt;pbone.net网站&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;常用第三方yum源&lt;/h3&gt;

&lt;p&gt;推荐三个常用的yum源:&lt;br/&gt;
&lt;a href=&quot;http://mirrors.fedoraproject.org/publiclist/EPEL/&quot;&gt;EPEL&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://pkgs.repoforge.org/rpmforge-release/&quot;&gt;rpmforge&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://download1.rpmfusion.org/&quot;&gt;rpmfusion&lt;/a&gt;&lt;br/&gt;
在系统安装完多个源之后，最好再安装一个小工具:&lt;a href=&quot;http://mirrors.ustc.edu.cn/centos/6.4/os/x86_64/Packages/yum-plugin-fastestmirror-1.1.30-14.el6.noarch.rpm&quot;&gt;fastestmirror&lt;/a&gt;帮助你自动找到下载最快的源&lt;/p&gt;

&lt;h3&gt;yum常用命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#yum info installed     //列出所有安装包的信息
#yum update [包名称] //更新指定包
#yum search [keyword]   //搜索包
#yum remove [包名称] //卸载指定包
#yum -y ...     //默认使用yes回答后续的提问
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://cissco.iteye.com/blog/397163&quot;&gt;CentOS 下 rpm包与 yum 安装与卸载&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>centos5.9使用记录</title>
   <link href="http://perthcharles.github.com/2013/03/11/232-centos59-using-log"/>
   <updated>2013-03-11T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/11/232-centos59-using-log</id>
   <content type="html">&lt;h3&gt;配置内网&lt;/h3&gt;

&lt;p&gt;更改文件：/etc/sysconfig/network-scripts/ifcfg-eth0&lt;br/&gt;
1,将dhcp改为static&lt;br/&gt;
2,添加IPADDR，NETMASK，GATEWAY，DNS等字段&lt;/p&gt;

&lt;h3&gt;配置外网连接&lt;/h3&gt;

&lt;p&gt;更改文件：/etc/resolv.conf,加入nameserver配置，然后重启网络服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#service network restart  
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>test search</title>
   <link href="http://perthcharles.github.com/2013/03/08/test-search"/>
   <updated>2013-03-08T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/08/test-search</id>
   <content type="html">

&lt;!--Google站内搜索开始--&gt;


&lt;p&gt;&lt;form method=get action=&quot;http://www.google.com/search&quot; target=&quot;_blank&quot;&gt;
&lt;input type=text name=q&gt;
&lt;input type=submit name=btnG value=&quot;搜索&quot;&gt;
&lt;input type=hidden name=ie value=utf-8&gt;
&lt;input type=hidden name=oe value=utf-8&gt;
&lt;input type=hidden name=hl value=zh-CN&gt;
&lt;input type=hidden name=domains value=&quot;perthcharles.github.io&quot;&gt;
&lt;input type=hidden name=sitesearch value=&quot;perthcharles.github.io&quot;&gt;
&lt;/form&gt;&lt;/p&gt;

&lt;!--Google站内搜索结束--&gt;

</content>
 </entry>
 
 <entry>
   <title>linux命令学习（四）</title>
   <link href="http://perthcharles.github.com/2013/03/08/linux-using-4"/>
   <updated>2013-03-08T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/08/linux-using-4</id>
   <content type="html">&lt;h3&gt;常用命令简介&lt;/h3&gt;

&lt;p&gt;cat:从第一行开始显示文件&lt;br/&gt;
tac:从最后一行开始显示文件&lt;br/&gt;
nl:显示的时候顺便显示行数&lt;br/&gt;
more:一页一页地显示文件内容&lt;br/&gt;
less：与more类似，但是支持向上翻页&lt;br/&gt;
head:只看头几行&lt;br/&gt;
tail:只看结尾几行&lt;br/&gt;
od:以二进制的方式读取文件内容（效果不太好，希望以后找到合适的工具）&lt;/p&gt;

&lt;h3&gt;一些更细节的解释&lt;/h3&gt;

&lt;p&gt;cat:是concatenate(连续)的简写&lt;br/&gt;
tail:如果想检测一个持续被写入的文件，可以输入下面的命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cat -f filename  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;-f&lt;/strong&gt;的含义是follow，是指將新增加(append)到文件的内容打印出来&lt;/p&gt;

&lt;hr /&gt;

&lt;h3&gt;用户能进入某个目录&lt;/h3&gt;

&lt;p&gt;让用户能够进入某个目录成为“可工作目录”的基本权限需求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;可使用的命令：例如cd等切换工作目录的命令  
目录所需权限：用户对这个目录至少需要有x权限  
额外需求：如果用户想要在这个目录内利用ls查阅文件名，则用户对此目录还要有r的权限  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;用户在某目录下读文件&lt;/h3&gt;

&lt;p&gt;用户在某个目录内读取一个文件的基本权限需求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;可使用的命令：例如cat,more,less等  
目录所需权限：用户对这个目录至少需要有x权限  
文件所选权限：用户对文件至少需要具有r的权限才行  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;用户修改文件&lt;/h3&gt;

&lt;p&gt;用户修改一个文件的基本权限需求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;可使用的命令：vim等  
目录所需权限：用户在该文件所在的目录至少需要x权限  
文件所需权限：用户对该文件至少要有r,w权限  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;其他注意&lt;/h4&gt;

&lt;p&gt;让一个用户可以创建一个文件的基本权限要求是用户在该目录要有w,x的权限&lt;br/&gt;
让用户进入某目录并执行该目录下的某个命令的基本权限要求是用户对目录和对应文件都至少要有x的权限&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>linux命令学习（三）</title>
   <link href="http://perthcharles.github.com/2013/03/08/linux-using"/>
   <updated>2013-03-08T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/08/linux-using</id>
   <content type="html">&lt;h3&gt;关于pwd&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#cd /var/mail   
#pwd    //显示当前完整路径  
/var/mail  
#pwd -P //显示当前真实路径，而非使用链接的路径  
/var/spool/mail  
#ls -al  
（前面略去...）/var/mail -&amp;gt; /var/spool/mail  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;当一个文件夹是一个链接文件时，上述两个命令的执行结果会出现上例中的不同&lt;/p&gt;

&lt;h3&gt;创建多层目录&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#mkdir test/test  
mkdir: cannot create directory `test/test`: No such file or directory  
#mkdir -p test/test  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数&lt;strong&gt;-p&lt;/strong&gt;將帮助你把不存在的上层目录建立起来&lt;br/&gt;
mkdir还有-m参数：手动配置文件属性，而不用默认值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;关于属性：r=4,w=2,x=1,故7=4+2+1表示具有可读可写可执行的权限  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;简易随机数&lt;/h3&gt;

&lt;p&gt;如果想生成一个随机数，linux环境下可以简单的输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#echo $RANDOM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这样的范围是在0～32767之间，如果想生成一个在某个范围之内的随机数呢？这里将用到命令bc完成任务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#echo $RANDOM*10/32767 | bc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先通过echo命令完成计算表达式，然后用bc计算出来&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>linux命令学习（二）</title>
   <link href="http://perthcharles.github.com/2013/03/05/linux-using"/>
   <updated>2013-03-05T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/05/linux-using</id>
   <content type="html">&lt;h3&gt;本地帮助文件&lt;/h3&gt;

&lt;p&gt;一般系统安装（yum、spt-get、手动）软件后，都会有一些帮助你使用或理解的文件，除了REAMME之外，还可以查看一个路径获得有更多信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cd /usr/share/doc/  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;whatis = man -f&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#whatis date  
date (1)             - print or set the system date and time  
#mam -f date  
date (1)             - print or set the system date and time  
更多请查看：  
#man man  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;关机前检查&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#who      //查看现在都有谁在线  
#netstat  //查看网络的联机状态  
#ps -aux  //查看后台程序  
#reboot   //重启电脑  
#shutdown -h now //立即关机  
#shutdown -r now //立即重启  
#shutdown -h 10  //10分钟后关机  
#poweroff           //断电关机  
#init 0          //执行等级设置为关机  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;linux常见目录及其含义&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#/  
    根目录(root)  
#/usr  
    软件存放位置(Unix Software Resource)  
#/etc  
    配置文件  
#/opt  
    第三方软件  
    更多的情况是会装到**/usr/local/**目录下  
#/boot  
    开机与内核文件  
    主要包括：Linux内核文件以及开机菜单和开机所需配置文件等  
    linux kernel常用的文件名为vmlinuz  
#/boot/grub  
    如果使用grub引导装载程序，会存在这个文件夹  
#/var  
    与系统运作过程有关  
#/bin  
    放置的是在单用户模式下**还**能够被操作的命令  
    主要有cat chmod chown date mv mkdir cp bash等常用命令   
#/dev  
    任何设备与接口设备都是以文件的形式存在于这个目录之中  
#/lib  
    放置开机时会用到的函数库  
    **/lib/modules**会放置内核相关的模块(驱动程序)  
#/media  
    放置可删除的设备  
#/mnt  
    如需临时挂载设备，建议挂载到这个目录下面  

#/sbin(system binary)  
    放置包括开机，修复，还原系统所需的命令。常见的有：fdisk,fsck,ifconfig,init,mkfs  
#/usr/sbin      服务器软件程序  
#/usr/local/sbin    自行安装的软件  

#/srv(service)  
    常见的有网络服务WWW，FTP  

#/lost+found  
    当文件系统发生错误时 ，將一些丢弃的片段放置到这个目录下  
    目录通常会在分区的最顶层  
#/proc  
    其实是虚拟文件系统，放置的内容都在内存中，不占用实际的硬盘空间  
#/sys   与/proc文件夹类似  
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>linux命令学习(一)</title>
   <link href="http://perthcharles.github.com/2013/03/01/linux-using"/>
   <updated>2013-03-01T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/2013/03/01/linux-using</id>
   <content type="html">&lt;h2&gt;查找软件安装位置方法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#whereis name-of-software  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;查看通过yum已安装的程序&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#rpm -qa |grep 程序名  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;du读取文件大小&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#man du  
#du -h  //自动的用更易读的方法输出结果  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;xargs（好用）&lt;/h2&gt;

&lt;p&gt;xargs能够將上一个命令的执行结果当作参数传递给下一个命令。忘记细节了，请记得：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#man xargs  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举例：將find找到的文件，传递给du命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#find /etc -name *id.conf |xargs du -h  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;删除文件夹内全部文件&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#rm -f *  //-f意味着不一一提示是否删除  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：当文件夹没文件过多或文件名长度过长，会导致&lt;em&gt;argument list too long&lt;/em&gt;的错误，我理解的原因就是正则式“*”展开导致命令行长度过长。这是UNIX以来就有的限制。查看限制可使用命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#getconf ARG_MAX  //我的电脑是2097152  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除所有文件：执行ls得到文件夹所有文件的路径，xargs將ls的输出，每10个一组（以空格为分割符）作为rm -rf 的参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ls |xargs -n 10 rm -rf  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除符合特定命名的文件,其实多少个一组是可选的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#find -name XXX |xargs [-n 10] rm -rf  
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>linux常用工具列表</title>
   <link href="http://perthcharles.github.com/linux-learning/2013/03/01/linux-tools"/>
   <updated>2013-03-01T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/linux-learning/2013/03/01/linux-tools</id>
   <content type="html">&lt;h3&gt;常用工具列表&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;git&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#git add *
#git commmit -a -m &quot;commit-name&quot;
#git push origin master
#git clone XXX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;xsel:命令行复制到剪切板&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cat filename |xsel -b -i  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;goagent：不懂的自己查去&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#python proxy.py  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;iconv:解决打开windows txt文件中乱码问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#iconv -f gbk -t utf8 from.txt &amp;gt; to.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;screen:实现在断开ssh的情况下，在服务器上继续执行程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#screen -S screen-name  //新建一个sreen
#ctrl+a+d       //先按ctrl+a,然后再按d即可保留screen，下次ssh连接服务器后可以重新进入这个screen
#exit           //如果在某个screen里面的工作完成后，该命令可以完全退出screen
#screen -ls     //查看目前在跑的screen
#screen -r screen-name or id    //恢复screen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;foxit reader&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#wget http://cdn04.foxitsoftware.com/pub/foxit/reader/desktop/linux/1.x/1.1/enu/FoxitReader-1.1-0.fc9.i386.rpm
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>linux系统信息</title>
   <link href="http://perthcharles.github.com/linux-learning/2013/03/01/linux-system-info"/>
   <updated>2013-03-01T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/linux-learning/2013/03/01/linux-system-info</id>
   <content type="html">&lt;h1&gt;系统信息相关&lt;/h1&gt;

&lt;h4&gt;查看系统发行版本号&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#cat /etc/issue
#lsb_release -a
#cat /etc/redhat-release(针对redhat,Fedora)  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;查看内核版本等信息&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#uname -a //a 表示 all  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多信息：&lt;a href=&quot;http://xiaozhen1900.blog.163.com/blog/static/17417325720115713351300/&quot;&gt;查看LINUX发行版的名称及其版本号的命令&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;linux下文件编码格式转换方法&lt;/h4&gt;

&lt;p&gt;推荐工具：enca&lt;br/&gt;
安装方法ubuntu：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#sudo apt-get install enca  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#enca -L zh_CN file  //检查file的编码
#enca -L zh_CN -x UTF-8 file //將file转换为UTF-8编码格式  
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>初识Jekyll</title>
   <link href="http://perthcharles.github.com/tools/2013/02/25/First-view-of-Jekyll"/>
   <updated>2013-02-25T00:00:00+08:00</updated>
   <id>http://perthcharles.github.com/tools/2013/02/25/First-view-of-Jekyll</id>
   <content type="html">&lt;h2&gt;关于 Jekyll&lt;/h2&gt;

&lt;p&gt;首先，Jekyll不是一个博客软件，更加准确的说法应该是一个解析器。当你按照Jekyll事先定义好的规则写好了一篇博客后，它会自动的將对应文件解析成最终的博客样式。&lt;/p&gt;

&lt;h2&gt;关于Page&lt;/h2&gt;

&lt;p&gt;Pages支持较多文件类型，我主要用MARKDOWN和HTML这两种文件类型。任何根目录下和不是以下划线开始的子文件夹下的Page文件都能够被Jekyll自动解析。&lt;/p&gt;

&lt;h2&gt;关于Post&lt;/h2&gt;

&lt;p&gt;新建一个post可以用下面的命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#rake post title=&quot;name of post&quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样产生的文件会在文件夹：_posts下，且后缀名为：&lt;strong&gt;md&lt;/strong&gt;&lt;br/&gt;
注意：后缀名不能为MARKUP，否则jekyll不能正确解析post文件&lt;/p&gt;

&lt;h2&gt;Categories和Tags&lt;/h2&gt;

&lt;p&gt;这两个功能只能针对post生效，对page没有作用。具体的用法是在post文件的最开始定义好这些内容。如这篇post对应的定义内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
title: 初识Jekyll
category : tools
tags : jekyll
---  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种定义形式叫做：YAML Front Matter，更多细节解释请查看&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front Matter&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;关于themes&lt;/h2&gt;

&lt;p&gt;现在用的主题名为：the program,安装方法为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#rake theme:install git=&quot;https://github.com/jekyllbootstrap/theme-the-program.git&quot;  
#rake theme:switch name=&quot;the-program&quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;我的posts列表样例&lt;/h2&gt;

&lt;ul class=&quot;posts&quot;&gt;
  
    &lt;li&gt;&lt;span&gt;22 May 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/05/22/inverse-number&quot;&gt;POJ上看到一种O(nm)求逆序数的方法&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;17 May 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/05/17/javascript-quick-learning&quot;&gt;javascript quick learning&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;14 May 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/%E9%9D%A2%E8%AF%95%E9%A2%98/2013/05/14/chinese_remainder_theorem&quot;&gt;中国剩余定理&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;11 May 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/Papers/2013/05/11/&quot;&gt;交互式程序性能评测&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;09 May 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/05/09/linuxgrep&quot;&gt;linux命令学习(七)：grep高级用法与正则表达式初步&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;08 May 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/05/08/cut-and-grep&quot;&gt;linux命令学习(六)：cut grep &amp;&amp; || sort wc uniq&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;27 Apr 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/04/27/kvm-qemu&quot;&gt;kvm qemu环境搭建&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;26 Apr 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/x%20window%20%E5%AD%A6%E4%B9%A0/2013/04/26/x-window&quot;&gt;x window学习笔记&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;25 Apr 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/2013/04/25/os-profile-line&quot;&gt;[编程之美]控制CPU使用率曲线&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;25 Apr 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/04/25/chrome-bugs&quot;&gt;chrome bugs&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;21 Apr 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/%E5%9B%BE%E8%AE%BA/2013/04/21/mst_parallel&quot;&gt;并行最小生成树算法&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;20 Apr 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/%E9%9D%A2%E8%AF%95%E9%A2%98/2013/04/20/problem-one&quot;&gt;已知a[N],求b[i]=a[0]*a[1]..a[N]/a[i]&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;19 Apr 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/04/19/mapreduce-learning&quot;&gt;mapreduce 学习笔记&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;13 Apr 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/papars/2013/04/13/trace-driven-survey&quot;&gt;Trace驱动的memory模拟：综述&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;12 Apr 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/04/12/linux-using&quot;&gt;linux 命令学习（五）&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;28 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/28/x-window&quot;&gt;X window&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;25 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/25/linux-disassemble&quot;&gt;linux 反汇编初步&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;25 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/25/gnu-as-pratice&quot;&gt;Gnu AS 汇编实践&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;24 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/24/ssh-free-pwd&quot;&gt;ssh免密码登录&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;24 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/%E9%9D%A2%E8%AF%95%E9%A2%98/2013/03/24/negation-in-c&quot;&gt;一道C语言二进制反码题&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;24 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/24/install-linux-from-disk&quot;&gt;硬盘安装linux&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;24 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/centos6.4/2013/03/24/centos-mount-ntfs&quot;&gt;在centos系统下，挂在ntfs格式的磁盘分区&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;23 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/23/vim-decode&quot;&gt;vim 编码相关问题&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;23 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/2013/03/23/utorrentmplayer&quot;&gt;utorrent+mplayer使用&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;23 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/benchmarks/2013/03/23/hp-bench&quot;&gt;Bench 安装记录&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;18 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/centos6.4/2013/03/18/yum-using&quot;&gt;yum使用指南&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;11 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/11/232-centos59-using-log&quot;&gt;centos5.9使用记录&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;08 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/08/test-search&quot;&gt;test search&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;08 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/08/linux-using-4&quot;&gt;linux命令学习（四）&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;08 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/08/linux-using&quot;&gt;linux命令学习（三）&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;05 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/05/linux-using&quot;&gt;linux命令学习（二）&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;01 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2013/03/01/linux-using&quot;&gt;linux命令学习(一)&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;01 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/linux-learning/2013/03/01/linux-tools&quot;&gt;linux常用工具列表&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;01 Mar 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/linux-learning/2013/03/01/linux-system-info&quot;&gt;linux系统信息&lt;/a&gt;&lt;/li&gt;
  
    &lt;li&gt;&lt;span&gt;25 Feb 2013&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/tools/2013/02/25/First-view-of-Jekyll&quot;&gt;初识Jekyll&lt;/a&gt;&lt;/li&gt;
  
&lt;/ul&gt;


&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://jiyeqian.github.com/2012/07/host-your-pages-at-github-using-jekyll/&quot;&gt;基于jekyll的github建站指南&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://twitter.github.com/bootstrap/&quot;&gt;Bootstrap官网&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://liquidmarkup.org/&quot;&gt;Liquid官网&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://www.mceiba.com/develop/liquid-learn.html&quot;&gt;使用Liquid模板语言&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://jekyllbootstrap.com/&quot;&gt;Zero to Hosted Jekyll Blog in 3 Minetes&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://www.soimort.org/posts/101/&quot;&gt;像黑客一样写博客--Jekyll入门&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;brionas.github.io/2013/03/01/test/&quot;&gt;快速入门指南&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 
</feed>